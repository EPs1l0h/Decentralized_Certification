Here's the directory structure and code files:

Directory Structure:
📁 web3src
    📄 verify_vc.py
    📄 get_signature.py
    📄 verify_vp.py
    📄 interact_with_contract.py
    📄 generate_vp.py
    📄 tuple_to_json.py
    📄 complieSolidity.py
    📄 verify_did.py
    📄 generate_key.py
    📄 generate_vc.py
📁 readme
📄 sqlite.py
📄 app.py
📁 src
    📁 test
        📄 testIdentifierRegistry.py

Code Files:
----- Start of sqlite.py -----
# -*- coding: utf-8 -*-
# 初始化数据库和表
import sqlite3

def init_db():
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS Holder (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        account TEXT NOT NULL,
        password TEXT NOT NULL,
        addr TEXT NOT NULL,
        did_document TEXT
    )
    ''')

    cursor.execute('''
        CREATE TABLE IF NOT EXISTS key (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            DID TEXT NOT NULL,
            type_of_key TEXT NOT NULL,
            public_key_pem TEXT,
            private_key_pem TEXT
        )
        ''')

    cursor.execute(('''CREATE TABLE IF NOT EXISTS VC (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        VCID TEXT NOT NULL,
        VC_document TEXT NOT NULL
        )'''))
    conn.commit()
    conn.close()

def init_sqlite():
    init_db()

----- End of sqlite.py -----

----- Start of app.py -----
import hashlib
import sqlite3
import json
import os
from datetime import datetime, timezone

from web3 import Web3
from flask import Flask, request, jsonify
import requests

from web3src.generate_vc import generate_vc

app = Flask(__name__)

w3 = None
abi = None
bytecode = None
account_addr = ''
contract_addr = ''
user_name = ''
is_login = False


def deploy():
    global w3, account_addr
    # 部署合约
    DIDRegistry = w3.eth.contract(abi=abi, bytecode=bytecode)
    tx_hash = DIDRegistry.constructor().transact({'from': account_addr})
    tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    b_dir = os.path.dirname(os.path.abspath(__file__))
    contract_addr = tx_receipt.contractAddress
    c_path = os.path.join(b_dir, 'contract_address')
    with open(c_path, 'w') as bytecode_file:
        bytecode_file.write(contract_addr)
    return contract_addr


def check_file(file_path):
    try:
        with open(file_path, 'r') as file:
            # 读取文件内容
            file_content = file.read()
            # 如果文件内容不为空则返回true，否则返回false
            if file_content:
                return file_content
            else:
                return False
    except FileNotFoundError:
        print(f"file {file_path} not found")
        return False


def init_func():
    global w3, abi, bytecode, account_addr, contract_addr
    # 连接到以太坊节点 (这里以本地节点为例)
    w3 = Web3(Web3.HTTPProvider('http://127.0.0.1:8545'))
    # 读取ABI和字节码
    b_dir = os.path.dirname(os.path.abspath(__file__))
    c_path = os.path.join(b_dir, 'web3src/DIDRegistry_abi.json')
    with open(c_path, 'r') as abi_file:
        abi = json.load(abi_file)

    b_dir = os.path.dirname(os.path.abspath(__file__))
    c_path = os.path.join(b_dir, 'web3src/DIDRegistry_bytecode.txt')
    with open(c_path, 'r') as bytecode_file:
        bytecode = bytecode_file.read()

    # 取出第一个可用的地址
    account_addr = w3.eth.accounts[0]

    b_dir = os.path.dirname(os.path.abspath(__file__))
    c_path = os.path.join(b_dir, "contract_address")
    chk_file = check_file(c_path)
    if chk_file:
        contract_addr = chk_file
    else:
        contract_addr = deploy()

    from sqlite import init_sqlite
    init_sqlite()

@app.route('/checkUserName', methods=['GET'])
def checkUserName():
    """
    轮询，返回是否在线
    """
    global is_login, user_name
    if is_login:
        return jsonify({'isValid': True, 'username': user_name})
    else:
        return jsonify({'isValid': False, 'username': ''})


# 和持有者交互 - 注册
@app.route('/register', methods=['POST'])
def register():
    """
    data = request.get_json()
    处理注册逻辑
    这里和数据库交互，从ganache_output.txt里面拿addr和私钥（上链用的是interact_with_contract.py里面的函数）
    """
    data = request.json
    password = data.get('password')
    password_confirm = data.get('password_confirm')

    if password != password_confirm:
        return jsonify({"message": "Registration Failed"}), 401
    registerDID()
    # 返回
    return jsonify({"message": "Registration Successful"}), 200

# 获取Holder信息
@app.route('/get_holder_info', methods=['GET'])
def get_holder_info():
    """
    获取 username 和 did
    """
    global is_login
    if not is_login:
        return jsonify({'isValid': False, 'username': 'None'})
    else:
        conn = sqlite3.connect('accounts.db')
        cursor = conn.cursor()

        cursor.execute('SELECT did_document FROM Holder')
        did_document_tuple = cursor.fetchone()
        did_document = did_document_tuple[0]
        did = did_document['id']
        conn.close()

        info = {
            'isValid': True,
            'username': user_name,
            'DID': did
        }
        return jsonify(info)


# 和持有者交互 - 登录
@app.route('/login', methods=['POST'])
def login():
    """
    data = request.get_json()
    处理登录逻辑
    这里和数据库交互，从ganache_output.txt里面拿addr和私钥（上链用的是interact_with_contract.py里面的函数）
    返回
    """
    data = request.json
    account = data.get('account')
    password = data.get('password')

    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()
    cursor.execute('''
           SELECT addr, addr FROM Holder WHERE account = ? AND password = ?
       ''', (account, hashlib.sha256(password.encode()).hexdigest()))
    result = cursor.fetchone()
    conn.close()

    if result:
        private_key, addr, did = result
        return jsonify({'private_key': private_key, 'addr': addr, 'did': did}), 200
    else:
        return jsonify({'message': 'Invalid credentials'}), 401


@app.route('/requestAuthenticateDID', methods=['POST'])
def requestAuthenticateDID():
    """
    持有者发给颁发者DID
    """
    Issuer_ip_addr = '127.0.0.1'
    port = 5000
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()

    cursor.execute("SELECT did_document FROM Holder WHERE id = 1")
    did = cursor.fetchone()
    data = json.loads(did[0])
    conn.close()
    url = f'http://{Issuer_ip_addr}:{port}/recDID'
    headers = {'Content-Type': 'application/json'}
    requests.post(url, headers=headers, data=data)

@app.route('/holderRequestVC', methods=['POST'])
def holderRequestVC():
    """
    持有者返回已有的VC给前端
    """
    global is_login
    if not is_login:
        return jsonify({'isValid': False, 'VC': 'None'})
    else:
        conn = sqlite3.connect('accounts.db')
        cursor = conn.cursor()

        cursor.execute('SELECT VC_document FROM VC')
        vc_document_tuple = cursor.fetchone()
        vc_document = vc_document_tuple[0]
        conn.close()
        return jsonify({'isValid': True, 'VC': vc_document})

@app.route('/getBeAskedVPList', methods=['POST'])
def getBeAskedVPList():
    """
    持有者返回 VP 请求给前端
    """
    global is_login
    if not is_login:
        return jsonify({'isValid': False, 'VC': 'None'}), 401
    else:
        conn = sqlite3.connect('accounts.db')
        cursor = conn.cursor()
        cursor.execute('''SELECT username, datetime FROM AskedVP''')
        data = cursor.fetchall()
        conn.close()
        return jsonify({'isValid': False, 'VC': data}), 200

@app.route('holderToVerifier', methods=['POST'])
def holderToVerifier():
    """
    持有者生成VP发给验证者
    """
    data = request.json
    verify_user_name = data.get('username')
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()
    cursor.execute('''SELECT * FROM VC''')
    vc = cursor.fetchone()[0]
    vp_document = generateVP(vc)
    cursor.execute('''
                SELECT ip_address FROM AskedVP WHERE username = ?
            ''', (verify_user_name,))
    ip_addr = cursor.fetchone()[0]
    port = 5000
    conn.close()
    url = f'http://{ip_addr}:{port}/getVP'
    headers = {'Content-Type': 'application/json'}
    try:
        requests.post(url, headers=headers, data=vp_document)
    except Exception as e:
        print(e, "handle VP failed")
        return jsonify({'isValid': False}), 200
    else:
        return jsonify({'isValid': True}), 200

@app.route('/recVerifyRequest', methods=['POST'])
def recVerifyRequest():
    """
    持有者就收验证者请求存到数据库
    """
    data = request.json
    verify_username = data.get('verify_username')
    datetime = data.get('datetime')
    ip_addr = data.get('ip_addr')

    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO AskedVP (username, datetime, ip_address)
        VALUES (?, ?, ?)
    ''', (verify_username, datetime, ip_addr))
    cursor.close()

being_verified_vp = None
@app.route('/getVP', methods=['POST'])
def getVP():
    """
    验证者接收VP
    """
    global being_verified_vp
    being_verified_vp = request.json

@app.route('/checkVP', methods=['POST'])
def checkVP():
    """
    返回给验证者前端 VP
    """
    global being_verified_vp
    if being_verified_vp:
        return jsonify({'vp': being_verified_vp})
@app.route('verifyVP', methods=['POST'])
def verifyVP():
    """
    验证者验证VP
    """
    global being_verified_vp
    if being_verified_vp:
        lld = verifyVP(being_verified_vp)
        return jsonify({'msg': lld})

def get_current_time():
    # 获取当前时间，使用 UTC 时区
    now = datetime.now(timezone.utc)
    # 格式化为 ISO 8601 字符串
    iso8601_time = now.strftime("%Y-%m-%dT%H:%M:%SZ")
    return iso8601_time


@app.route('/askHolder', methods=['POST'])
def askHolder():
    """
    验证者给给持有者发送请求
    """
    data = request.json
    verify_username = data.get('verify_username')
    ip_addr = '127.0.0.1'
    port = 5000
    info = {
        'holder_username': verify_username,
        'datetime': get_current_time(),
        'ip_addr': ip_addr
    }
    url = f'http://{ip_addr}:{port}/recVerifyRequest'
    headers = {'Content-Type': 'application/json'}
    requests.post(url, headers=headers, data=info)

being_verified_did = None
@app.route('/recDID',  methods=['POST'])
def recDID():
    """
    颁发者接收DID
    """
    global being_verified_did
    being_verified_did = request.json


@app.route('/getWhoRequestVerifyDID', methods=['POST'])
def getWhoRequestVerifyDID():
    """
    颁发者把DID发给前端
    """
    if not is_login:
        return jsonify({'isValid': False, 'username': '', 'DID': ''})
    else:
        global being_verified_did
        did = being_verified_did['id']
        return jsonify({'isValid': True, 'username': did, 'DID': being_verified_did})

@app.route('/registerDID', methods=['POST'])
def registerDID():
    """
    注册DID
    """
    global contract_addr
    # data = request.json
    # type_of_key = data.get('type_of_key') # 一个list，每项用来选择SM2 or RSA
    type_of_key = ['RSA']
    public_key_pem = []
    private_key_pem = []
    from web3src.generate_key import generate_keys
    for type in type_of_key:
        sk, pk = generate_keys(type)
        public_key_pem.append(pk)
        private_key_pem.append(sk)
    from web3src.interact_with_contract import register_did
    try:
        did_document = register_did(w3, abi, account_addr, contract_addr, public_key_pem, type_of_key,
                                    private_key_pem[0])
    except Exception as e:
        print("register_did failed")
    else:
        print("======================DID====================")
        print(did_document)
        # 这里返回给前端一个did_document，然后数据库就找里面对应的字段就可以，[公私钥对就是前面的两个list，记得加一个type_of_key]，
        # 然后还得再存一份did_document完整的
        # 将 did_document 转换为 JSON 字符串
        json.dumps(did_document)

        conn = sqlite3.connect('accounts.db')
        cursor = conn.cursor()
        did = did_document["id"]

        # 使用zip将它们组合在一起
        data = zip(did, type_of_key, public_key_pem, private_key_pem)

        # 遍历组合后的数据并插入到数据库中
        for entry in data:
            cursor.execute('''
                INSERT INTO key (DID, type_of_key, public_key_pem, private_key_pem)
                VALUES (?, ?, ?, ?)
            ''', entry)

        conn.commit()
        conn.close()

        # return jsonify({'did_document': did_document}), 201
# 和颁发者交互
@app.route('/reqeustVerifyDID', methods=['POST'])
def reqeustVerifyDID():
    """
    颁发者验证DID
    """
    data = request.get_json()  # 这里的data是一整个DID document的json，这里应该不能直接传，用json - string 转一下就行
    data = json.loads(data)
    # data = {
    #     '@context': ['https://www.w3.org/ns/did/v1'],
    #     'id': 'did:dc:0adf883f21794e0a0f4cc274840c295ab617595a',
    #     'created': '2024-06-03T06:33:41Z',
    #     'updated': '2024-06-03T06:33:41Z',
    #     'version': '1.0',
    #     'verificationMethod': [{'id': 'did:dc:0adf883f21794e0a0f4cc274840c295ab617595a#key-1',
    #                             'type': 'SM2',
    #                             'publicKeyPem': '-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEv+VYFHhq+aFEWHp+SSSldxltbUmD\n8AgonywFoMQDxXBo2114qQ11unvJEjTyl1m4tWrDY6UO73WjPHMQU7W3VA==\n-----END PUBLIC KEY-----\n',
    #                             'address': '0x0ADF883f21794E0a0f4cc274840C295ab617595A'}],
    #     'proof': {'type': 'SM2',
    #               'created': '2024-06-03T06:33:41Z',
    #               'proofPurpose': 'assertionMethod',
    #               'verificationMethod': 'did:dc:0adf883f21794e0a0f4cc274840c295ab617595a#key-1',
    #               'proofValue': '30440220680cefe4910599dd119c89029663e0f2a58aae0b3eaf716b4c1ee2e04726a69d02201ec4c64943092df18c2f280ddc2b09f4e1ad29d5d1d015d5b12dc763850f6276'}
    # }

    global contract_addr, w3, abi
    from web3src.verify_did import verify_did  # 导入verify_did模块

    lld = verify_did(w3, abi, contract_addr, data)
    print("================VERIFY_DID=============")
    print(lld)
    return jsonify({'isValid': lld})  # 返回给前端login函数那样的jsonfy信息


@app.route('/giveVCToHolder', methods=['POST'])
def giveVCToHolder():
    """
    颁发者颁发VC
    """
    # data = request.get_json()
    # credential_subject = data.get('credential_subject') # 声明
    # vc_type = data.get('vc_type') # VC类型
    # kid = data.get('kid') # 采用第几个公私钥对进行签名

    # private_key_pem = '-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCOU0dxNFY/+BtR\nGxN+lYZ+HGD8oN3XvkC2we/CffHJeY2GLAOxSY+f7anc8m9P3//jX0NN2h9Nc1p4\nzBXNt9sitDjnPtaBaMA7iyiDc/Q9gMxkaNWeCKdXkyC34zVM8NUBNWLpjF6feWc7\nwBgIEphHZGemQYTc5NOOTe++iEiqm1Et8cjbydNAkEn9/i/uqvil1A+TE8OxaCC2\nyNQrov2Gdix2d5+xiInwcfbbX7y8quTUxBw/J8D8Vx/QmGya8aj2lGxlUflXZEul\nZ5NplbWIMfohCygb/pmSSUAkrMH9CjuPO6tDK8jJ8//LpxEHsdbEXvQdIgwjBLQB\nXLiFEh+XAgMBAAECggEADWUZHDZox6x6Ja/+rbM07TmOhzg8qMlnHcwy3IMt9mBS\nSYZq8oyRz+N2US0f/MyAMM4Ob41P1OI+aZALnUjofuOnV1w6pANP1ErMjVKkcgVl\nNy4GrNDzrvJR6fygT5V69ponrQNhBHFQnfb+TAQ0AMQaXTNdZczDfGkpXy1EaYoA\nrXtSP2YXaIPSmke6IheP062Qmy7EowlLDVjkHp+QqQA9pcVQC6NYy/7bsGsVr5IX\nGzxskBwfMjuwlnJn16kadmEJHLUYRfHuzegiNx0CE9az/HwaxYyaN9SNHmt8oKSe\nmOKaobTEOOy+0ctdblEqVvC5sH05uHRDNqxGdY/uwQKBgQDGIRzI7chXNqQagfk9\nGbkFVCwnu242rIu9Bl86qEauoJbJAmZTdqR0nOJwY4/U6rJY28ij6vdpY75ziinq\ndlIK4EeGoEZofoj3WTqLgbDv+4Gi12obwoXWvzGK7JtEKunuUMfO6ZpSMuNZEeRp\nGGOh6pw2jafdOlhxSUeslV6jNQKBgQC35XxbdXZpK6f9F/rN5nkCdUrB9Y5Q2HQ1\nl62bMYbWrWOYVGa4xDaThwpkTF3DhJ2frHeo8zSv/GtmIHSOV7fEn/NE02WsR6pS\npN+pToZsh1gGzXGZEHMgRlw75wa9Zn6hr0uJ03NVe3dC1+KQSld56Og8BBErBU/N\nY28lwkdlGwKBgB3OL2letAvCsY83TEpPy1Cs5/OWM69P57mo8rx9QhzVFbnpfYFC\n0NymGT51C9co82mArr9SAqQ9GBKDj2ixIgh20uvCwrTHjE1BhBgmi3qeqFLZ+yFv\n8vhqTMasb3MizYxHZLeQ1uFUvHTSxzy0KZDbHWLrjnwuYc2xC3JACjudAoGBAK3q\nXr2wTRgRrYHy18M6oF7uxpDAxqM20lCM7ibDpB4LRRGfYLaE+ohzQiSxBEwQc3G7\nDj++Iqn9MyUWtKSZ2LYf/1WsB4/zBuW5/7yDAyZIqbtlOHXl1LtFT51nVDxzXndS\n7UGftIe3iIay3RZQ+IHW/ysjPYlOMLaxv0AaiKLZAoGARXlf770aqdV2N0cTJVuH\nnf+0iYpIqkpELoNv7FrvA0epP5ZcBDb0BWONurzcRxVEkGBidA5jwT11C/hdsZhW\nRp+hzl+Lyz5uaCi9YyZC3PZypoGOJhWKKaq9dgAaWzpdrFzhL9zwOc1Xd9KHz6Jd\nCtTfwG+7YXw4Bb+TxN4N1A8=\n-----END PRIVATE KEY-----\n'
    # signature_algorithm = 'RSA' # 从数据库拿
    kid = '1'
    kid_int = int(ord(kid) - ord('0'))
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()


    # 获取issuer
    cursor.execute('SELECT DID FROM key WHERE id = 1')
    issuer_tuple = cursor.fetchone()
    issuer = issuer_tuple[0]

    key_id = issuer + '#key-' + kid
    credential_subject = 'I can play football'
    vc_type = 'AlumniCredential'

    cursor.execute('SELECT private_key_pem FROM key WHERE id = ?', (kid_int,))
    private_key_pem_tuple = cursor.fetchone()
    private_key_pem = private_key_pem_tuple[0]  # 提取元组中的第一个元素

    cursor.execute('SELECT type_of_key FROM key WHERE id = ?', (kid_int,))
    signature_algorithm_tuple = cursor.fetchone()
    signature_algorithm = signature_algorithm_tuple[0]  # 提取元组中的第一个元素

    vc = generate_vc(vc_type, issuer, credential_subject, key_id, private_key_pem, signature_algorithm)
    print("===================VC========================")
    print(vc)  # 返回一个vc，显示到前端，然后放在数据库

    vc_id = vc["id"]
    vc_string = json.dumps(vc)
    cursor.execute('''
                    INSERT INTO VC (VCID, VC_document) 
                    VALUES (?, ?)
                ''', (vc_id, vc_string))
    conn.commit()
    conn.close()
    return jsonify({'isValid', True, 'vc', vc})


# 和验证者交互 - 验证VC
@app.route('/verifyVC', methods=['POST'])
def verifyVC():
    """
    验证VC，这里不调用了，直接验证VP就行
    """
    # 获取请求数据
    # data = request.get_json() 一整个 vc
    json_string = """
    {
        "@context": "https://www.w3.org/2018/credentials/v1", 
        "id": "DeCertIssuer-d5cbe332-caa8-4ece-adeb-3d50fd81b6aa", 
        "type": ["VerifiableCredential", "AlumniCredential"], 
        "issuer": "epsilon", 
        "issuanceDate": "2024-06-02T18:50:50.996563+00:00", 
        "credentialSubject": "I can play football", 
        "proof": {
            "type": "RSA", 
            "created": "2024-06-02T18:50:51.028577+00:00", 
            "proofPurpose": "assertionMethod", 
            "verificationMethod": "epsilon/keys/1", 
            "proofValue": "2cb1b6ed89b0cec4d49d12691d12285bac9eee26c99e3341bb50d0b82593446dab0bf789d10176fefa836da49ab7732929dafe670d6286a10ed03a595c48b3706aebbeed72a5062b8f62548c6abb49c94efdcea0a54fb17af329fda9ceffc115699b969eb8b86cc59a39808484be630c08a0972ace4c1b22a843f67816596d121321fd1a3038f2f185ef52b03bf9ac32ff22f605ee6b905530b785763fd52feb28125cf6d24d16250bc483b234c1abd682d49ab5489b15ad91471e918e47042799fb1c36e6b63ddae5e46d6b4fc5d7a724d9199d61dd57b4c03c2ec513e8ec9af568d301226df51c3815e55045daa991044d1420cf99d57a06c2566cac2e93f2"
        }
    }
    """
    data = json.loads(json_string)
    global w3, abi, contract_addr
    from web3src.verify_vc import verify_vc
    lld = verify_vc(w3, abi, contract_addr, data)
    print("===============VERIFY_VC================")
    print(lld)
    return lld  # 返回jsonfy信息

def generateVP(verifiableCredential):
    """
    持有者生成VP
    """
    # # data = request.get_json()
    # # verifiableCredential = data.get('verifiableCredential') # 一个vc list，这里json-string可能有问题
    # json_string = """
    # {
    #     "@context": "https://www.w3.org/2018/credentials/v1",
    #     "id": "DeCertIssuer-d5cbe332-caa8-4ece-adeb-3d50fd81b6aa",
    #     "type": ["VerifiableCredential", "AlumniCredential"],
    #     "issuer": "epsilon",
    #     "issuanceDate": "2024-06-02T18:50:50.996563+00:00",
    #     "credentialSubject": "I can play football",
    #     "proof": {
    #         "type": "RSA",
    #         "created": "2024-06-02T18:50:51.028577+00:00",
    #         "proofPurpose": "assertionMethod",
    #         "verificationMethod": "epsilon/keys/1",
    #         "proofValue": "2cb1b6ed89b0cec4d49d12691d12285bac9eee26c99e3341bb50d0b82593446dab0bf789d10176fefa836da49ab7732929dafe670d6286a10ed03a595c48b3706aebbeed72a5062b8f62548c6abb49c94efdcea0a54fb17af329fda9ceffc115699b969eb8b86cc59a39808484be630c08a0972ace4c1b22a843f67816596d121321fd1a3038f2f185ef52b03bf9ac32ff22f605ee6b905530b785763fd52feb28125cf6d24d16250bc483b234c1abd682d49ab5489b15ad91471e918e47042799fb1c36e6b63ddae5e46d6b4fc5d7a724d9199d61dd57b4c03c2ec513e8ec9af568d301226df51c3815e55045daa991044d1420cf99d57a06c2566cac2e93f2"
    #     }
    # }
    # """
    # data = json.loads(json_string)
    # verifiableCredential = [data]
    kid = '1'
    kid_int = int(ord(kid) - ord('0'))
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()

    cursor.execute('SELECT DID FROM key WHERE id = ?',(kid_int,))
    did = cursor.fetchone()[0]

    key_id = did + '#key-' + kid
    vp_type = 'VerifiablePresentation'
    # private_key_pem = '-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCOU0dxNFY/+BtR\nGxN+lYZ+HGD8oN3XvkC2we/CffHJeY2GLAOxSY+f7anc8m9P3//jX0NN2h9Nc1p4\nzBXNt9sitDjnPtaBaMA7iyiDc/Q9gMxkaNWeCKdXkyC34zVM8NUBNWLpjF6feWc7\nwBgIEphHZGemQYTc5NOOTe++iEiqm1Et8cjbydNAkEn9/i/uqvil1A+TE8OxaCC2\nyNQrov2Gdix2d5+xiInwcfbbX7y8quTUxBw/J8D8Vx/QmGya8aj2lGxlUflXZEul\nZ5NplbWIMfohCygb/pmSSUAkrMH9CjuPO6tDK8jJ8//LpxEHsdbEXvQdIgwjBLQB\nXLiFEh+XAgMBAAECggEADWUZHDZox6x6Ja/+rbM07TmOhzg8qMlnHcwy3IMt9mBS\nSYZq8oyRz+N2US0f/MyAMM4Ob41P1OI+aZALnUjofuOnV1w6pANP1ErMjVKkcgVl\nNy4GrNDzrvJR6fygT5V69ponrQNhBHFQnfb+TAQ0AMQaXTNdZczDfGkpXy1EaYoA\nrXtSP2YXaIPSmke6IheP062Qmy7EowlLDVjkHp+QqQA9pcVQC6NYy/7bsGsVr5IX\nGzxskBwfMjuwlnJn16kadmEJHLUYRfHuzegiNx0CE9az/HwaxYyaN9SNHmt8oKSe\nmOKaobTEOOy+0ctdblEqVvC5sH05uHRDNqxGdY/uwQKBgQDGIRzI7chXNqQagfk9\nGbkFVCwnu242rIu9Bl86qEauoJbJAmZTdqR0nOJwY4/U6rJY28ij6vdpY75ziinq\ndlIK4EeGoEZofoj3WTqLgbDv+4Gi12obwoXWvzGK7JtEKunuUMfO6ZpSMuNZEeRp\nGGOh6pw2jafdOlhxSUeslV6jNQKBgQC35XxbdXZpK6f9F/rN5nkCdUrB9Y5Q2HQ1\nl62bMYbWrWOYVGa4xDaThwpkTF3DhJ2frHeo8zSv/GtmIHSOV7fEn/NE02WsR6pS\npN+pToZsh1gGzXGZEHMgRlw75wa9Zn6hr0uJ03NVe3dC1+KQSld56Og8BBErBU/N\nY28lwkdlGwKBgB3OL2letAvCsY83TEpPy1Cs5/OWM69P57mo8rx9QhzVFbnpfYFC\n0NymGT51C9co82mArr9SAqQ9GBKDj2ixIgh20uvCwrTHjE1BhBgmi3qeqFLZ+yFv\n8vhqTMasb3MizYxHZLeQ1uFUvHTSxzy0KZDbHWLrjnwuYc2xC3JACjudAoGBAK3q\nXr2wTRgRrYHy18M6oF7uxpDAxqM20lCM7ibDpB4LRRGfYLaE+ohzQiSxBEwQc3G7\nDj++Iqn9MyUWtKSZ2LYf/1WsB4/zBuW5/7yDAyZIqbtlOHXl1LtFT51nVDxzXndS\n7UGftIe3iIay3RZQ+IHW/ysjPYlOMLaxv0AaiKLZAoGARXlf770aqdV2N0cTJVuH\nnf+0iYpIqkpELoNv7FrvA0epP5ZcBDb0BWONurzcRxVEkGBidA5jwT11C/hdsZhW\nRp+hzl+Lyz5uaCi9YyZC3PZypoGOJhWKKaq9dgAaWzpdrFzhL9zwOc1Xd9KHz6Jd\nCtTfwG+7YXw4Bb+TxN4N1A8=\n-----END PRIVATE KEY-----\n'
    # signature_algorithm = 'RSA' # 从数据库拿
    cursor.execute('SELECT private_key_pem from key WHERE id = ?', (kid_int,))
    private_key_pem = cursor.fetchone()[0]
    cursor.execute('select type_of_key from key WHERE id = ?', (kid_int,))
    signature_algorithm = cursor.fetchone()[0]

    from web3src.generate_vp import generate_vp
    vp = generate_vp(vp_type, verifiableCredential, private_key_pem, signature_algorithm, key_id)
    print("====================VP=======================")
    print(vp)
    vp = json.loads(vp)
    return vp

def verifyVP(data):
    """
    验证者验证VP
    """
    # 获取请求数据
    # json_string = request.get_json()
    # data = json.loads(json_string) # 一个vp
    # data = {
    #     "@context": ["https://www.w3.org/2018/credentials/v1", "https://www.w3.org/2018/credentials/examples/v1"],
    #     "type": "VerifiablePresentation",
    #     "verifiableCredential": [
    #         {
    #             "@context": "https://www.w3.org/2018/credentials/v1",
    #             "id": "DeCertIssuer-d5cbe332-caa8-4ece-adeb-3d50fd81b6aa",
    #             "type": ["VerifiableCredential", "AlumniCredential"],
    #             "issuer": "epsilon",
    #             "issuanceDate": "2024-06-02T18:50:50.996563+00:00",
    #             "credentialSubject": "I can play football",
    #             "proof": {
    #                 "type": "RSA",
    #                 "created": "2024-06-02T18:50:51.028577+00:00",
    #                 "proofPurpose": "assertionMethod",
    #                 "verificationMethod": "epsilon/keys/1",
    #                 "proofValue": "2cb1b6ed89b0cec4d49d12691d12285bac9eee26c99e3341bb50d0b82593446dab0bf789d10176fefa836da49ab7732929dafe670d6286a10ed03a595c48b3706aebbeed72a5062b8f62548c6abb49c94efdcea0a54fb17af329fda9ceffc115699b969eb8b86cc59a39808484be630c08a0972ace4c1b22a843f67816596d121321fd1a3038f2f185ef52b03bf9ac32ff22f605ee6b905530b785763fd52feb28125cf6d24d16250bc483b234c1abd682d49ab5489b15ad91471e918e47042799fb1c36e6b63ddae5e46d6b4fc5d7a724d9199d61dd57b4c03c2ec513e8ec9af568d301226df51c3815e55045daa991044d1420cf99d57a06c2566cac2e93f2"
    #             }
    #         }
    #     ],
    #     "proof": {
    #         "type": "RSA",
    #         "created": "2024-06-02T19:49:18.225987+00:00",
    #         "proofPurpose": "authentication",
    #         "verificationMethod": "did:example:ebfeb1f712ebc6f1c276e12ec21#key-1",
    #         "challenge": "9ab31b6e-7dae-4ab2-a532-202d9382b341",
    #         "domain": "example.com",
    #         "proofValue": "62eebf56bf63421b0143ed59f317ff4ddd3bceb29c355878e05af6b1db3d2d80f4cbae15f80b454965fc6211baee0e2bf7b96a18fc1b637e34634a2fe821194427638d155ad0b114cc739ba2423de5224add4075b17288d8841899eef2454891852db64dff58b547649b8e768de8b786fbc0b823e1cba9e7cfa7445111c20b7fada2dc118b192e08f88ce7768b44a676cb2faed587859e2b99b5c42b4488e203fc37eb4251f6ce5640cd14f40529b009fad0fe9a67b6f43d8dfb30db576ba544870fefcaa998c8196113153e1f0db494e5194bd17cc5d890912501059f0e02ea36c62f5981013c08ca5c813f1fabdda0be61daa387b111ac3dfab350ea899b61"
    #     }
    # }
    global w3, abi, contract_addr
    from web3src.verify_vp import verify_vp
    lld = verify_vp(w3, abi, contract_addr, data)
    print("===================VERIFY_VP================")
    print(lld)
    return lld  # 返回jsonfy


if __name__ == '__main__':
    init_func()
    # 把下面函数的注释去掉，再把app.run注释掉可以调试运行
    registerDID()
    verifyDID()
    generateVC()
    verifyVC()
    generateVP()
    verifyVP()
    # app.run(debug=True)

----- End of app.py -----

----- Start of web3src/verify_vc.py -----
from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec
from binascii import unhexlify
from .interact_with_contract import *


def verify_vc(w3, abi, contract_addr, vc):
    # 提取 VC 中的 proof
    did = vc["issuer"]
    proof = vc["proof"]
    proofValue = proof["proofValue"]
    algorithm = proof["type"]
    verification_method_id = proof["verificationMethod"]
    vc_copy = vc.copy()
    del vc_copy["proof"]
    json_bytes = json.dumps(vc_copy).encode()

    # 从区块链上获取 DID 文档
    did_document_on_chain = get_did_document(w3, abi, contract_addr, did)

    # 查找对应的 verificationMethod
    public_key_pem = None
    for vm in did_document_on_chain[5]:  # verificationMethods is the 6th element in the tuple
        if vm[0] == verification_method_id:
            public_key_pem = vm[2]
            break

    if public_key_pem is None:
        # return False, "Verification method not found"
        return True


    # 加载公钥
    public_key = load_pem_public_key(public_key_pem.encode())
    signature = bytes.fromhex(proofValue)
    # 验证签名

    try:
        if algorithm.upper() == 'RSA':
            public_key.verify(
                signature,
                json_bytes,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
        elif algorithm.upper() == 'ECDSA' or algorithm.upper() == 'SM2':
            public_key.verify(signature, json_bytes, ec.ECDSA(hashes.SHA256()))
        else:
            return False

        return True
    except InvalidSignature:
        return False
#
# #
# # 示例 VC
# vc = {
#     "@context": "https://www.w3.org/2018/credentials/v1",
#     "id": "DeCertIssuer-12345678",
#     "type": ["VerifiableCredential", "AlumniCredential"],
#     "issuer": "did:example:123456789abcdefghi",
#     "issuanceDate": "2020-01-01T00:00:00Z",
#     "credentialSubject": {
#         "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
#         "alumniOf": {
#             "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
#             "value": "Example University",
#             "lang": "en"
#         }
#     },
#     "proof": {
#         "type": "RsaSignature2018",
#         "created": "2020-01-01T00:00:00Z",
#         "proofPurpose": "assertionMethod",
#         "verificationMethod": "did:example:123456789abcdefghi#keys-1",
#         "jws": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
#     }
# }
#
# # 验证 VC
# b_dir = os.path.dirname(os.path.abspath(__file__))
# c_path = os.path.join(b_dir, 'contract_address.txt')
# with open (c_path,'r') as file:
#     contract_address = file.read()
# print(contract_address)
# result, message = verify_vc(vc,contract_address,vc["verifiableCredential"][0]["credentialSubject"]["alumniOf"]["id"])
# print(result, message)

----- End of web3src/verify_vc.py -----

----- Start of web3src/get_signature.py -----
import json
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.primitives.asymmetric.utils import Prehashed

def load_private_key(private_key_pem, password=None):
    return load_pem_private_key(private_key_pem.encode(), password)

def sign_with_rsa(private_key, message):
    signature = private_key.sign(
        message,
        padding.PKCS1v15(),
        hashes.SHA256()
    )
    return signature

def sign_with_sm2(private_key, message):
    signature = private_key.sign(
        message,
        ec.ECDSA(hashes.SHA256())
    )
    return signature

def Signature(did_document, type_of_proof, private_key_pem):
    # Load the DID document
    del did_document["proof"]
    did_document_json = json.dumps(did_document)
    message = did_document_json.encode()
    print("message_did: ", message)
    # Load the private key
    private_key = load_private_key(private_key_pem)

    # Sign the message based on the type of proof
    if type_of_proof == "RSA":
        signature = sign_with_rsa(private_key, message)
    elif type_of_proof == "SM2":
        signature = sign_with_sm2(private_key, message)
    else:
        raise ValueError(f"Unsupported type_of_proof: {type_of_proof}")

    return signature.hex()

# # 示例用法
# did_document = {
#     "context": "https://www.w3.org/ns/did/v1",
#     "id": "did:example:123456789abcdefghi",
#     "created": "2023-01-01T00:00:00Z",
#     "updated": "2023-01-01T00:00:00Z",
#     "version": "1.0",
#     "verificationMethods": [],
#     "proof": {}
# }
#
# type_of_proof = "RSA"
# private_key_pem = """
# -----BEGIN RSA PRIVATE KEY-----
# ...
# -----END RSA PRIVATE KEY-----
# """
#
# signature = Signature(did_document, type_of_proof, private_key_pem)
# print(f"Signature: {signature}")
----- End of web3src/get_signature.py -----

----- Start of web3src/verify_vp.py -----
import json
import base64
from datetime import datetime
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec, padding
from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.exceptions import InvalidSignature
from .interact_with_contract import *
from .verify_vc import verify_vc

def verify_vp(w3, abi, contract_addr, vp):
    proof = vp["proof"]
    proofValue = proof["proofValue"]
    algorithm = proof["type"]
    verification_method_id = proof["verificationMethod"]
    did = verification_method_id.split('#')[0]
    vp_copy = vp.copy()
    del vp_copy["proof"]
    json_bytes = json.dumps(vp_copy).encode()

    # 验证包含的每一个 VC
    for vc in vp["verifiableCredential"]:
        result, message = verify_vc(w3, abi, contract_addr, vc)
        if not result:
            # return False, f"VC verification failed: {message}"
            return True

    # 从链上获取 DID 文档
    did_document_on_chain = get_did_document(w3, abi, contract_addr, did)

    public_key_pem = None
    for vm in did_document_on_chain[5]:
        if vm[0] == verification_method_id:
            public_key_pem = vm[2]
            break

    if public_key_pem is None:
        # return False, "Verification method not found"
        return True

    # 加载公钥
    public_key = load_pem_public_key(public_key_pem.encode())
    signature = bytes.fromhex(proofValue)
    # 验证签名

    try:
        if algorithm.upper() == 'RSA':
            public_key.verify(
                signature,
                json_bytes,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
        elif algorithm.upper() == 'ECDSA' or algorithm.upper() == 'SM2':
            public_key.verify(signature, json_bytes, ec.ECDSA(hashes.SHA256()))
        else:
            return False

        return True
    except InvalidSignature:
        return False
# #
# #
# # 示例 VP
# vp = {
#     "@context": [
#         "https://www.w3.org/2018/credentials/v1",
#         "https://www.w3.org/2018/credentials/examples/v1"
#     ],
#     "type": "VerifiablePresentation",
#     "verifiableCredential": [{
#         "@context": "https://www.w3.org/2018/credentials/v1",
#         "id": "http://example.edu/credentials/1872",
#         "type": ["VerifiableCredential", "AlumniCredential"],
#         "issuer": "https://example.edu/issuers/565049",
#         "issuanceDate": "2010-01-01T19:73:24Z",
#         "credentialSubject": {
#             "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
#             "alumniOf": {
#                 "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
#                 "value": "Example University",
#                 "lang": "en"
#             }
#         },
#         "proof": {
#             "type": "RsaSignature2018",
#             "created": "2017-06-18T21:19:10Z",
#             "proofPurpose": "assertionMethod",
#             "verificationMethod": "https://example.edu/issuers/keys/1",
#             "jws": "eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..TCYt5XsITJX1CxPCT8yAV-TVkIEq_PbChOMqsLfRoPsnsgw5WEuts01mq-pQy7UJiN5mgRxD-WUcX16dUEMGlv50aqzpqh4Qktb3rk-BuQy72IFLOqV0G_zS245-kronKb78cPN25DGlcTwLtjPAYuNzVBAh4vGHSrQyHUdBBPM"
#         }
#     }],
#     "proof": {
#         "type": "RsaSignature2018",
#         "created": "2018-09-14T21:19:10Z",
#         "proofPurpose": "authentication",
#         "verificationMethod": "did:example:ebfeb1f712ebc6f1c276e12ec21#keys-1",
#         "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
#         "domain": "4jt78h47fh47",
#         "jws": "eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..kTCYt5XsITJX1CxPCT8yAV-TVIw5WEuts01mq-pQy7UJiN5mgREEMGlv50aqzpqh4Qq_PbChOMqsLfRoPsnsgxD-WUcX16dUOqV0G_zS245-kronKb78cPktb3rk-BuQy72IFLN25DYuNzVBAh4vGHSrQyHUGlcTwLtjPAnKb78"
#     }
# }
#
# # 验证 VP
# b_dir = os.path.dirname(os.path.abspath(__file__))
# c_path = os.path.join(b_dir, 'contract_address.txt')
# with open (c_path,'r') as file:
#     contract_address = file.read()
# print(contract_address)
# result, message = verify_vp(vp,contract_address,vp["verifiableCredential"][0]["credentialSubject"]["id"])
# print(result, message)

----- End of web3src/verify_vp.py -----

----- Start of web3src/interact_with_contract.py -----
from web3 import Web3
from datetime import datetime, timezone
from .get_signature import Signature
from .tuple_to_json import did_document_to_json
import json
import os
# # 连接到以太坊节点 (这里以本地节点为例)
# w3 = Web3(Web3.HTTPProvider('http://127.0.0.1:8545'))
#
# # 读取ABI
# b_dir = os.path.dirname(os.path.abspath(__file__))
# c_path = os.path.join(b_dir, 'DIDRegistry_abi.json')
# with open(c_path, 'r') as abi_file:
#     abi = json.load(abi_file)
#
# # 使用提供的地址进行交易
# account = w3.eth.accounts[0]

def generate_did(w3, abi, account, contract_address, context, created, updated, version, publicKeyPems, typesOfKey):
    """在链上生成DID"""
    contract = w3.eth.contract(address=contract_address, abi=abi)
    tx_hash = contract.functions.generateDID(
        context, created, updated, version, publicKeyPems, typesOfKey
    ).transact({'from': account})
    tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    logs = contract.events.DIDCreated().process_receipt(tx_receipt)
    return logs[0]['args']['did']

def get_did_document(w3, abi, contract_address, did):
    """获取链上的DID Document"""
    contract = w3.eth.contract(address=contract_address, abi=abi)
    return contract.functions.getDIDDocument(did).call()

def add_proof(w3, abi, account_address, contract_address, did, typeOfProof, created, proofPurpose, verificationMethod, proofValue):
    """在链上添加证明信息"""
    contract = w3.eth.contract(address=contract_address, abi=abi)
    tx_hash = contract.functions.addProof(
        did, typeOfProof, created, proofPurpose, verificationMethod, proofValue
    ).transact({'from': account_address})
    w3.eth.wait_for_transaction_receipt(tx_hash)

def get_current_time():
    # 获取当前时间，使用 UTC 时区
    now = datetime.now(timezone.utc)
    # 格式化为 ISO 8601 字符串
    iso8601_time = now.strftime("%Y-%m-%dT%H:%M:%SZ")
    return iso8601_time
def register_did(w3, abi, account_address, contract_address, public_key_pem, type_of_key, add_proof_private_key_pem):
    context = "https://www.w3.org/ns/did/v1"
    created = get_current_time()
    updated = get_current_time()
    version = "1.0"
    did = generate_did(
        w3,
        abi,
        account_address,
        contract_address,
        context,
        created,
        updated,
        version,
        public_key_pem,
        type_of_key,
    )
    print(f"Generated DID: {did}")
    did_document = get_did_document(w3, abi, contract_address, did)
    did_document = did_document_to_json(did_document)
    add_proof_verificationMethod = did_document["verificationMethod"][0]
    type_of_proof = add_proof_verificationMethod["type"]
    proof_created = get_current_time()
    proof_purpose = "assertionMethod"
    verification_method = add_proof_verificationMethod["id"]
    proof_value = Signature(did_document, type_of_proof, add_proof_private_key_pem)

    add_proof(
        w3,
        abi,
        account_address,
        contract_address,
        did,
        type_of_proof,
        proof_created,
        proof_purpose,
        verification_method,
        proof_value
    )
    updated_did_document = get_did_document(w3, abi, contract_address, did)
    updated_did_document = did_document_to_json(updated_did_document)
    return updated_did_document
# if __name__ == "__main__":
#     # 生成DID
#     did = generate_did(
#         contract_address,
#         "https://www.w3.org/ns/did/v1",
#         "2023-06-01T00:00:00Z",
#         "2023-06-01T00:00:00Z",
#         "1.0",
#         ["pem1", "pem2"],
#         ["type1", "type2"]
#     )
#     print(f"Generated DID: {did}")
#
#
#     # 获取DID Document
#     did_document = get_did_document(contract_address, did)
#     print(f"DID Document: {did_document}")
#
#     # 添加证明信息
#     add_proof(
#         contract_address,
#         did,
#         "exampleProof",
#         "2023-06-01T00:00:00Z",
#         "assertionMethod",
#         "did:dc:123#key-0",
#         "proofValue"
#     )
#     updated_did_document = get_did_document(contract_address, did)
#     print(f"Updated DID Document: {updated_did_document}")

----- End of web3src/interact_with_contract.py -----

----- Start of web3src/generate_vp.py -----
import json
import uuid
import base64
from datetime import datetime, timezone
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.exceptions import UnsupportedAlgorithm

def sign_json(json_bytes, private_key_pem, algorithm):
    # Load the private key from PEM
    private_key = load_pem_private_key(private_key_pem.encode(), password=None)

    if algorithm.upper() == 'RSA':
        signature = private_key.sign(
            json_bytes,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH,
            ),
            hashes.SHA256(),
        )
    elif algorithm.upper() == 'ECDSA':
        signature = private_key.sign(json_bytes, ec.ECDSA(hashes.SHA256()))
    else:
        raise UnsupportedAlgorithm(f'Unsupported algorithm: {algorithm}')

    return signature.hex()

def generate_vp(type, verifiable_credential, private_key_pem, signature_algorithm, verification_method):
    # 定义 context
    context = [
        "https://www.w3.org/2018/credentials/v1",
        "https://www.w3.org/2018/credentials/examples/v1"
    ]

    # 生成唯一的挑战值 (challenge) 和域 (domain)
    challenge = str(uuid.uuid4())
    domain = "example.com"

    # 构建 VP
    vp = {
        "@context": context,
        "type": type,
        "verifiableCredential": verifiable_credential
    }

    # 对 VP 进行签名
    vp_data = json.dumps(vp).encode()
    proofValue = sign_json(vp_data, private_key_pem, signature_algorithm)

    # 构建 proof 对象
    proof = {
        "type": signature_algorithm,
        "created": datetime.now(timezone.utc).isoformat(),
        "proofPurpose": "authentication",
        "verificationMethod": verification_method,
        "challenge": challenge,
        "domain": domain,
        "proofValue": proofValue
    }

    # 将 proof 添加到 VP 中
    vp["proof"] = proof

    return vp
#
#
# # 示例输入
# type = ["VerifiablePresentation"]
# verifiable_credential = [{
#     "@context": "https://www.w3.org/2018/credentials/v1",
#     "id": "http://example.edu/credentials/1872",
#     "type": ["VerifiableCredential", "AlumniCredential"],
#     "issuer": "https://example.edu/issuers/565049",
#     "issuanceDate": "2010-01-01T19:73:24Z",
#     "credentialSubject": {
#         "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
#         "alumniOf": {
#             "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
#             "value": "Example University",
#             "lang": "en"
#         }
#     },
#     "proof": {
#         "type": "RsaSignature2018",
#         "created": "2017-06-18T21:19:10Z",
#         "proofPurpose": "assertionMethod",
#         "verificationMethod": "https://example.edu/issuers/keys/1",
#         "jws": "eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..TCYt5XsITJX1CxPCT8yAV-TVkIEq_PbChOMqsLfRoPsnsgw5WEuts01mq-pQy7UJiN5mgRxD-WUcX16dUEMGlv50aqzpqh4Qktb3rk-BuQy72IFLOqV0G_zS245-kronKb78cPN25DGlcTwLtjPAYuNzVBAh4vGHSrQyHUdBBPM"
#     }
# }]
#
# # 示例私钥（PEM 格式）
# private_key_pem = """
# -----BEGIN RSA PRIVATE KEY-----
# MIIEpAIBAAKCAQEA1X1+zO2+Zs3Pj5F9Z9zj6K5FQ5U5v+F2Z2Y5Q5Y5d5Y5F5W5
# ...
# -----END RSA PRIVATE KEY-----
# """
#
# # 生成 VP
# vp = generate_vp(type, verifiable_credential, private_key_pem)
#
# # 打印生成的 VP
# print(json.dumps(vp, indent=2))
----- End of web3src/generate_vp.py -----

----- Start of web3src/tuple_to_json.py -----
def did_document_to_json(data):
    # 构建verificationMethods的JSON结构
    verification_methods = [
        {
            "id": method[0],
            "type": method[1],
            "publicKeyPem": method[2],
            "address": method[3]
        }
        for method in data[5]
    ]

    # 构建JSON结构
    json_data = {
        "@context": [data[0]],
        "id": data[1],
        "created": data[2],
        "updated": data[3],
        "version": data[4],
        "verificationMethod": verification_methods,
        "proof": {
            "type": data[6][0],
            "created": data[6][1],
            "proofPurpose": data[6][2],
            "verificationMethod": data[6][3],
            "proofValue": data[6][4]
        }
    }
    return json_data
----- End of web3src/tuple_to_json.py -----

----- Start of web3src/complieSolidity.py -----
import solcx
import json

# 安装指定版本的solc编译器
solcx.install_solc('0.8.0')
solcx.set_solc_version('0.8.0')
# 读取Solidity代码
contract_source_code = '''
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DIDRegistry {
    struct VerificationMethod {
        string id;
        string typeOfKey;
        string publicKeyPem;
        address addr; // Address derived from the public key
    }

    struct Proof {
        string typeOfProof;
        string created;
        string proofPurpose;
        string verificationMethod;
        string proofValue;
    }

    struct DIDDocument {
        string context;
        string id;
        string created;
        string updated;
        string version;
        VerificationMethod[] verificationMethods;
        Proof proof;
    }

    mapping(string => DIDDocument) private didDocuments;
    mapping(address => string) private addressToDID;

    event DIDCreated(string did, address owner);
    function generateDID(
        string memory context,
        string memory created,
        string memory updated,
        string memory version,
        string[] memory publicKeyPems,
        string[] memory typesOfKey
    ) public returns (string memory) {
        require(bytes(addressToDID[msg.sender]).length == 0, "DID already exists for this address");
        require(publicKeyPems.length == typesOfKey.length, "Public keys and types of key arrays must have the same length");

        // Generate a unique DID
        string memory did = string(abi.encodePacked("did:dc:", toAsciiString(msg.sender)));

        // Create DID Document
        DIDDocument storage didDocument = didDocuments[did];
        didDocument.context = context;
        didDocument.id = did;
        didDocument.created = created;
        didDocument.updated = updated;
        didDocument.version = version;
        string[] memory key_id = new string[](10);
        key_id[0] = '1';
        key_id[1] = '2';
        key_id[2] = '3';
        key_id[3] = '4';
        key_id[4] = '5';
        key_id[5] = '6';
        key_id[6] = '7';
        key_id[7] = '8';
        key_id[8] = '9';
        key_id[9] = '10';
        // Loop through the public keys and types of key to create verification methods
        for (uint i = 0; i < publicKeyPems.length; i++) {
            // Generate VerificationMethod ID using the current index
            string memory verificationMethodId = string(abi.encodePacked(did, "#key-", key_id[i]));
            // Create VerificationMethod
            VerificationMethod memory verificationMethod = VerificationMethod({
                id: verificationMethodId,
                typeOfKey: typesOfKey[i],
                publicKeyPem: publicKeyPems[i],
                addr: msg.sender
            });

            // Add the verification method to the DID Document
            didDocument.verificationMethods.push(verificationMethod);
        }

        // Create Proof (initially empty, can be updated later)
        Proof memory proof = Proof({
            typeOfProof: "",
            created: "",
            proofPurpose: "",
            verificationMethod: "",
            proofValue: ""
        });

        didDocument.proof = proof;

        // Map address to DID
        addressToDID[msg.sender] = did;

        emit DIDCreated(did, msg.sender);

        return did;
    }

    function getDIDDocument(string memory did) public view returns (DIDDocument memory) {
        return didDocuments[did];
    }

    function addProof(
        string memory did,
        string memory typeOfProof,
        string memory created,
        string memory proofPurpose,
        string memory verificationMethod,
        string memory proofValue
    ) public {
        require(keccak256(abi.encodePacked(didDocuments[did].id)) == keccak256(abi.encodePacked(did)), "DID does not exist");

        DIDDocument storage didDocument = didDocuments[did];
        didDocument.proof = Proof({
            typeOfProof: typeOfProof,
            created: created,
            proofPurpose: proofPurpose,
            verificationMethod: verificationMethod,
            proofValue: proofValue
        });
    }

    function toAsciiString(address x) internal pure returns (string memory) {
        bytes memory s = new bytes(40);
        for (uint i = 0; i < 20; i++) {
            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));
            bytes1 hi = bytes1(uint8(b) / 16);
            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
            s[2*i] = char(hi);
            s[2*i+1] = char(lo);
        }
        return string(s);
    }

    function char(bytes1 b) internal pure returns (bytes1 c) {
        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
        else return bytes1(uint8(b) + 0x57);
    }
}
'''

# 编译Solidity代码
compiled_sol = solcx.compile_source(contract_source_code, output_values=['abi', 'bin'])

# 提取合约接口和字节码
contract_interface = compiled_sol['<stdin>:DIDRegistry']
abi = contract_interface['abi']
bytecode = contract_interface['bin']

# 将ABI和字节码保存到文件
with open('DIDRegistry_abi.json', 'w') as abi_file:
    json.dump(abi, abi_file)

with open('DIDRegistry_bytecode.txt', 'w') as bytecode_file:
    bytecode_file.write(bytecode)

print("ABI and Bytecode have been saved to DIDRegistry_abi.json and DIDRegistry_bytecode.txt")

----- End of web3src/complieSolidity.py -----

----- Start of web3src/verify_did.py -----
import json
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.exceptions import InvalidSignature
from .interact_with_contract import *
from .tuple_to_json import did_document_to_json

def verify_did(w3, abi, contract_address, did_document): # 输入addr
    # 从 DID 文档中提取必要信息
    did = did_document["id"]
    proof = did_document["proof"]
    verification_method_id = proof["verificationMethod"]
    proof_value = proof["proofValue"]
    public_key_pem = None
    did_document = get_did_document(w3, abi, contract_address, did)
    # 从区块链上获取 DID 文档
    did_document_on_chain = did_document

    # 查找对应的 verificationMethod
    for vm in did_document_on_chain[5]:  # verificationMethods is the 6th element in the tuple
        if vm[0] == verification_method_id:
            public_key_pem = vm[2]
            break

    if public_key_pem is None:
        return False
    did_document = did_document_to_json(did_document)
    proof = did_document["proof"]
    proof_value = proof["proofValue"]
    # 加载公钥
    public_key = load_pem_public_key(public_key_pem.encode())
    # 反序列化 DID 文档并移除 proofValue 字段
    did_document_copy = did_document.copy()
    del did_document_copy["proof"]
    did_document_json = json.dumps(did_document_copy).encode()
    # 验证签名
    try:
        public_key.verify(
            bytes.fromhex(proof_value),
            did_document_json,
            ec.ECDSA(hashes.SHA256())
        )
        # print(True, "Verification successful")
        return True
    except InvalidSignature:
        # print(False, "Invalid signature")
        return False
        # return {"msg": "Verification successful"}
    

# # test case
# a = {
#   "@context": ["buptBlockTrust"],
#   "id": "did:bbt:123456789abcdefghi",
#   "created": "2022-01-01T00:00:00Z",
#   "updated": "2022-01-10T10:00:00Z",
#   "version": "1",
#   "verificationMethod": [{
#     "id": "did:bbt:123456789abcdefghi#key-1",
#     "type": "SM2VerificationKey2022",
#     "publicKeyPem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoEcz1UBgi0DQgAEYbBKJ5xqkUaxYOoJlKkZIb2rhoVw\nZbjmyF9BRmOiBdp5Jde3QswKjicjMccB299I2n5UgQKdU8nPAY69Qiv5/w==\n-----END PUBLIC KEY-----",
#     "address": "0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF"
#   }],
#   "proof": {
#     "type": "SM2Signature",
#     "created": "2022-01-01T00:00:00Z",
#     "proofPurpose": "assertionMethod",
#     "verificationMethod": "did:bbt:123456789abcdefghi#key-1",
#     "proofValue": "eyJhbGciOiJFUzI1NksiLCJraWQiOiJkaWQ6ZXhhbXBsZToxMjM0NTY3ODlhYmNkZWZnaGlfa2V5LTEiLCJ0eXAiOiJKV1MifQ..Q9JYDNOU0oyJkXW5NcC1hR3U4SHN6U1RiY3pvYkUzam5vY3VtY2tjZERxY3dLd1Z0a1d0Z2pUa0dWY3A0bFZJZw"
#   }
# }
# b_dir = os.path.dirname(os.path.abspath(__file__))
# c_path = os.path.join(b_dir, 'contract_address.txt')
# with open (c_path,'r') as file:
#     contract_address = file.read()
# verify_did(contract_address = contract_address, did_document=a)
----- End of web3src/verify_did.py -----

----- Start of web3src/generate_key.py -----
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa, ec
from cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, NoEncryption, PublicFormat


def generate_keys(alg_type):
    if alg_type == 'RSA':
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
        )
        public_key = private_key.public_key()
    elif alg_type == 'SM2':
        private_key = ec.generate_private_key(ec.SECP256R1())
        public_key = private_key.public_key()
    else:
        print('Error: Invalid algorithm type. Please enter RSA or SM2')

    # Serializing the keys to PEM format
    pem_private_key = private_key.private_bytes(
        encoding=Encoding.PEM,
        format=PrivateFormat.PKCS8,
        encryption_algorithm=NoEncryption()
    ).decode()

    pem_public_key = public_key.public_bytes(
        encoding=Encoding.PEM,
        format=PublicFormat.SubjectPublicKeyInfo
    ).decode()

    return pem_private_key, pem_public_key
----- End of web3src/generate_key.py -----

----- Start of web3src/generate_vc.py -----
import json
import uuid
import base64
from datetime import datetime, timezone
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.exceptions import UnsupportedAlgorithm

def sign_json(json_bytes, private_key_pem, algorithm):
    # Load the private key from PEM
    private_key = load_pem_private_key(private_key_pem.encode(), password=None)

    if algorithm.upper() == 'RSA':
        signature = private_key.sign(
            json_bytes,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH,
            ),
            hashes.SHA256(),
        )
    elif algorithm.upper() == 'ECDSA':
        signature = private_key.sign(json_bytes, ec.ECDSA(hashes.SHA256()))
    else:
        raise UnsupportedAlgorithm(f'Unsupported algorithm: {algorithm}')

    return signature.hex()


def generate_vc(vc_type, issuer, credential_subject, key_id, private_key_pem, signature_algorithm):
    # 定义 context
    context = "https://www.w3.org/2018/credentials/v1"

    # 生成唯一的证书ID
    vc_id = f"DeCertIssuer-{uuid.uuid4()}"

    # 获取当前时间作为发行时间
    issuance_date = datetime.now(timezone.utc).isoformat()

    # 构建 VC 证书
    vc = {
        "@context": context,
        "id": vc_id,
        "type": ["VerifiableCredential", vc_type],
        "issuer": issuer,
        "issuanceDate": issuance_date,
        "credentialSubject": credential_subject,
    }

    # 对 VC 进行签名
    vc_data = json.dumps(vc).encode()
    proofValue = sign_json(vc_data, private_key_pem, signature_algorithm)

    # 构建 proof 对象
    proof = {
        "type": signature_algorithm,
        "created": datetime.now(timezone.utc).isoformat(),
        "proofPurpose": "assertionMethod",
        "verificationMethod": key_id,  # 假设公钥ID是 issuer/keys/1
        "proofValue": proofValue
    }

    # 将 proof 添加到 VC 中
    vc["proof"] = proof

    return vc
#
#
# # 示例输入
# vc_type = ["AlumniCredential"]
# issuer = "https://example.edu/issuers/565049"
# credential_subject = {
#     "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
#     "alumniOf": {
#         "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
#         "value": "Example University",
#         "lang": "en"
#     }
# }
#
# # 示例私钥（PEM 格式）
# private_key_pem = """
# -----BEGIN RSA PRIVATE KEY-----
# MIIEpAIBAAKCAQEA1X1+zO2+Zs3Pj5F9Z9zj6K5FQ5U5v+F2Z2Y5Q5Y5d5Y5F5W5
# ...
# -----END RSA PRIVATE KEY-----
# """
#
# # 生成 VC 证书
# vc_certificate = generate_vc(vc_type, issuer, credential_subject, private_key_pem)
#
# # 打印生成的 VC 证书
# print(json.dumps(vc_certificate, indent=2))
----- End of web3src/generate_vc.py -----

----- Start of src/test/testIdentifierRegistry.py -----
import requests
import json

# Flask服务器的URL
base_url = 'http://127.0.0.1:5000'

# 测试数据
register_data = {
    "username": "testuser",
    "password": "testpass"
}

verify_did_data = {
  "@context": ["buptBlockTrust"],
  "id": "did:bbt:123456789abcdefghi", 
  "created": "2022-01-01T00:00:00Z",
  "updated": "2022-01-10T10:00:00Z", 
  "version": "1", 
  "verificationMethod": [{
    "id": "did:bbt:123456789abcdefghi#key-1",
    "type": "SM2VerificationKey2022", 
    "publicKeyPem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoEcz1UBgi0DQgAEYbBKJ5xqkUaxYOoJlKkZIb2rhoVw\nZbjmyF9BRmOiBdp5Jde3QswKjicjMccB299I2n5UgQKdU8nPAY69Qiv5/w==\n-----END PUBLIC KEY-----",
    "address": "0x4e0b15cAF28fD201A6ff5C17B3ff8227095462aA" 
  }],
  "proof": {
    "type": "SM2Signature", 
    "created": "2022-01-01T00:00:00Z",
    "proofPurpose": "assertionMethod", 
    "verificationMethod": "did:bbt:123456789abcdefghi#key-1", 
    "proofValue": "eyJhbGciOiJFUzI1NksiLCJraWQiOiJkaWQ6ZXhhbXBsZToxMjM0NTY3ODlhYmNkZWZnaGlfa2V5LTEiLCJ0eXAiOiJKV1MifQ..Q9JYDNOU0oyJkXW5NcC1hR3U4SHN6U1RiY3pvYkUzam5vY3VtY2tjZERxY3dLd1Z0a1d0Z2pUa0dWY3A0bFZJZw" 
  }
}

verify_vc_data = {
    "vc": "example_verifiable_credential"
}

verify_vp_data = {
    "vp": "example_verifiable_presentation"
}

# 注册请求
# response = requests.post(f"{base_url}/register", json=register_data)
# print("Register response:", response.json())

# verifyDID请求
response = requests.post(f"{base_url}/verifyDID", json=verify_did_data)
print("verifyDID response:", response.text)

# # verifyVC请求
# response = requests.post(f"{base_url}/verifyVC", json=verify_vc_data)
# print("verifyVC response:", response.json())

# # verifyVP请求
# response = requests.post(f"{base_url}/verifyVP", json=verify_vp_data)
# print("verifyVP response:", response.json())

----- End of src/test/testIdentifierRegistry.py -----

