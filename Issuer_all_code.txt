Here's the directory structure and code files:

Directory Structure:
ðŸ“ web3src
    ðŸ“„ verify_vc.py
    ðŸ“„ get_signature.py
    ðŸ“„ verify_vp.py
    ðŸ“„ interact_with_contract.py
    ðŸ“„ generate_vp.py
    ðŸ“„ tuple_to_json.py
    ðŸ“„ complieSolidity.py
    ðŸ“„ verify_did.py
    ðŸ“„ generate_key.py
    ðŸ“„ generate_vc.py
ðŸ“ readme
ðŸ“„ sqlite.py
ðŸ“„ app.py
ðŸ“ src
    ðŸ“ test
        ðŸ“„ testIdentifierRegistry.py

Code Files:
----- Start of sqlite.py -----
# -*- coding: utf-8 -*-
# åˆå§‹åŒ–æ•°æ®åº“å’Œè¡¨
import sqlite3

def init_db():
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS Holder (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        account TEXT NOT NULL,
        password TEXT NOT NULL,
        addr TEXT NOT NULL,
        did_document TEXT
    )
    ''')

    cursor.execute('''
        CREATE TABLE IF NOT EXISTS key (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            DID TEXT NOT NULL,
            type_of_key TEXT NOT NULL,
            public_key_pem TEXT,
            private_key_pem TEXT
        )
        ''')

    cursor.execute(('''CREATE TABLE IF NOT EXISTS VC (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        VCID TEXT NOT NULL,
        VC_document TEXT NOT NULL
        )'''))
    conn.commit()
    conn.close()

def init_sqlite():
    init_db()

----- End of sqlite.py -----

----- Start of app.py -----
import hashlib
import sqlite3
import json
import os
from datetime import datetime, timezone

from web3 import Web3
from flask import Flask, request, jsonify
import requests

from web3src.generate_vc import generate_vc

app = Flask(__name__)

w3 = None
abi = None
bytecode = None
account_addr = ''
contract_addr = ''
user_name = ''
is_login = False


def deploy():
    global w3, account_addr
    # éƒ¨ç½²åˆçº¦
    DIDRegistry = w3.eth.contract(abi=abi, bytecode=bytecode)
    tx_hash = DIDRegistry.constructor().transact({'from': account_addr})
    tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    b_dir = os.path.dirname(os.path.abspath(__file__))
    contract_addr = tx_receipt.contractAddress
    c_path = os.path.join(b_dir, 'contract_address')
    with open(c_path, 'w') as bytecode_file:
        bytecode_file.write(contract_addr)
    return contract_addr


def check_file(file_path):
    try:
        with open(file_path, 'r') as file:
            # è¯»å–æ–‡ä»¶å†…å®¹
            file_content = file.read()
            # å¦‚æžœæ–‡ä»¶å†…å®¹ä¸ä¸ºç©ºåˆ™è¿”å›žtrueï¼Œå¦åˆ™è¿”å›žfalse
            if file_content:
                return file_content
            else:
                return False
    except FileNotFoundError:
        print(f"file {file_path} not found")
        return False


def init_func():
    global w3, abi, bytecode, account_addr, contract_addr
    # è¿žæŽ¥åˆ°ä»¥å¤ªåŠèŠ‚ç‚¹ (è¿™é‡Œä»¥æœ¬åœ°èŠ‚ç‚¹ä¸ºä¾‹)
    w3 = Web3(Web3.HTTPProvider('http://127.0.0.1:8545'))
    # è¯»å–ABIå’Œå­—èŠ‚ç 
    b_dir = os.path.dirname(os.path.abspath(__file__))
    c_path = os.path.join(b_dir, 'web3src/DIDRegistry_abi.json')
    with open(c_path, 'r') as abi_file:
        abi = json.load(abi_file)

    b_dir = os.path.dirname(os.path.abspath(__file__))
    c_path = os.path.join(b_dir, 'web3src/DIDRegistry_bytecode.txt')
    with open(c_path, 'r') as bytecode_file:
        bytecode = bytecode_file.read()

    # å–å‡ºç¬¬ä¸€ä¸ªå¯ç”¨çš„åœ°å€
    account_addr = w3.eth.accounts[0]

    b_dir = os.path.dirname(os.path.abspath(__file__))
    c_path = os.path.join(b_dir, "contract_address")
    chk_file = check_file(c_path)
    if chk_file:
        contract_addr = chk_file
    else:
        contract_addr = deploy()

    from sqlite import init_sqlite
    init_sqlite()

@app.route('/checkUserName', methods=['GET'])
def checkUserName():
    """
    è½®è¯¢ï¼Œè¿”å›žæ˜¯å¦åœ¨çº¿
    """
    global is_login, user_name
    if is_login:
        return jsonify({'isValid': True, 'username': user_name})
    else:
        return jsonify({'isValid': False, 'username': ''})


# å’ŒæŒæœ‰è€…äº¤äº’ - æ³¨å†Œ
@app.route('/register', methods=['POST'])
def register():
    """
    data = request.get_json()
    å¤„ç†æ³¨å†Œé€»è¾‘
    è¿™é‡Œå’Œæ•°æ®åº“äº¤äº’ï¼Œä»Žganache_output.txté‡Œé¢æ‹¿addrå’Œç§é’¥ï¼ˆä¸Šé“¾ç”¨çš„æ˜¯interact_with_contract.pyé‡Œé¢çš„å‡½æ•°ï¼‰
    """
    data = request.json
    password = data.get('password')
    password_confirm = data.get('password_confirm')

    if password != password_confirm:
        return jsonify({"message": "Registration Failed"}), 401
    registerDID()
    # è¿”å›ž
    return jsonify({"message": "Registration Successful"}), 200

# èŽ·å–Holderä¿¡æ¯
@app.route('/get_holder_info', methods=['GET'])
def get_holder_info():
    """
    èŽ·å– username å’Œ did
    """
    global is_login
    if not is_login:
        return jsonify({'isValid': False, 'username': 'None'})
    else:
        conn = sqlite3.connect('accounts.db')
        cursor = conn.cursor()

        cursor.execute('SELECT did_document FROM Holder')
        did_document_tuple = cursor.fetchone()
        did_document = did_document_tuple[0]
        did = did_document['id']
        conn.close()

        info = {
            'isValid': True,
            'username': user_name,
            'DID': did
        }
        return jsonify(info)


# å’ŒæŒæœ‰è€…äº¤äº’ - ç™»å½•
@app.route('/login', methods=['POST'])
def login():
    """
    data = request.get_json()
    å¤„ç†ç™»å½•é€»è¾‘
    è¿™é‡Œå’Œæ•°æ®åº“äº¤äº’ï¼Œä»Žganache_output.txté‡Œé¢æ‹¿addrå’Œç§é’¥ï¼ˆä¸Šé“¾ç”¨çš„æ˜¯interact_with_contract.pyé‡Œé¢çš„å‡½æ•°ï¼‰
    è¿”å›ž
    """
    data = request.json
    account = data.get('account')
    password = data.get('password')

    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()
    cursor.execute('''
           SELECT addr, addr FROM Holder WHERE account = ? AND password = ?
       ''', (account, hashlib.sha256(password.encode()).hexdigest()))
    result = cursor.fetchone()
    conn.close()

    if result:
        private_key, addr, did = result
        return jsonify({'private_key': private_key, 'addr': addr, 'did': did}), 200
    else:
        return jsonify({'message': 'Invalid credentials'}), 401


@app.route('/requestAuthenticateDID', methods=['POST'])
def requestAuthenticateDID():
    """
    æŒæœ‰è€…å‘ç»™é¢å‘è€…DID
    """
    Issuer_ip_addr = '127.0.0.1'
    port = 5000
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()

    cursor.execute("SELECT did_document FROM Holder WHERE id = 1")
    did = cursor.fetchone()
    data = json.loads(did[0])
    conn.close()
    url = f'http://{Issuer_ip_addr}:{port}/recDID'
    headers = {'Content-Type': 'application/json'}
    requests.post(url, headers=headers, data=data)

@app.route('/holderRequestVC', methods=['POST'])
def holderRequestVC():
    """
    æŒæœ‰è€…è¿”å›žå·²æœ‰çš„VCç»™å‰ç«¯
    """
    global is_login
    if not is_login:
        return jsonify({'isValid': False, 'VC': 'None'})
    else:
        conn = sqlite3.connect('accounts.db')
        cursor = conn.cursor()

        cursor.execute('SELECT VC_document FROM VC')
        vc_document_tuple = cursor.fetchone()
        vc_document = vc_document_tuple[0]
        conn.close()
        return jsonify({'isValid': True, 'VC': vc_document})

@app.route('/getBeAskedVPList', methods=['POST'])
def getBeAskedVPList():
    """
    æŒæœ‰è€…è¿”å›ž VP è¯·æ±‚ç»™å‰ç«¯
    """
    global is_login
    if not is_login:
        return jsonify({'isValid': False, 'VC': 'None'}), 401
    else:
        conn = sqlite3.connect('accounts.db')
        cursor = conn.cursor()
        cursor.execute('''SELECT username, datetime FROM AskedVP''')
        data = cursor.fetchall()
        conn.close()
        return jsonify({'isValid': False, 'VC': data}), 200

@app.route('holderToVerifier', methods=['POST'])
def holderToVerifier():
    """
    æŒæœ‰è€…ç”ŸæˆVPå‘ç»™éªŒè¯è€…
    """
    data = request.json
    verify_user_name = data.get('username')
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()
    cursor.execute('''SELECT * FROM VC''')
    vc = cursor.fetchone()[0]
    vp_document = generateVP(vc)
    cursor.execute('''
                SELECT ip_address FROM AskedVP WHERE username = ?
            ''', (verify_user_name,))
    ip_addr = cursor.fetchone()[0]
    port = 5000
    conn.close()
    url = f'http://{ip_addr}:{port}/getVP'
    headers = {'Content-Type': 'application/json'}
    try:
        requests.post(url, headers=headers, data=vp_document)
    except Exception as e:
        print(e, "handle VP failed")
        return jsonify({'isValid': False}), 200
    else:
        return jsonify({'isValid': True}), 200

@app.route('/recVerifyRequest', methods=['POST'])
def recVerifyRequest():
    """
    æŒæœ‰è€…å°±æ”¶éªŒè¯è€…è¯·æ±‚å­˜åˆ°æ•°æ®åº“
    """
    data = request.json
    verify_username = data.get('verify_username')
    datetime = data.get('datetime')
    ip_addr = data.get('ip_addr')

    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO AskedVP (username, datetime, ip_address)
        VALUES (?, ?, ?)
    ''', (verify_username, datetime, ip_addr))
    cursor.close()

being_verified_vp = None
@app.route('/getVP', methods=['POST'])
def getVP():
    """
    éªŒè¯è€…æŽ¥æ”¶VP
    """
    global being_verified_vp
    being_verified_vp = request.json

@app.route('/checkVP', methods=['POST'])
def checkVP():
    """
    è¿”å›žç»™éªŒè¯è€…å‰ç«¯ VP
    """
    global being_verified_vp
    if being_verified_vp:
        return jsonify({'vp': being_verified_vp})
@app.route('verifyVP', methods=['POST'])
def verifyVP():
    """
    éªŒè¯è€…éªŒè¯VP
    """
    global being_verified_vp
    if being_verified_vp:
        lld = verifyVP(being_verified_vp)
        return jsonify({'msg': lld})

def get_current_time():
    # èŽ·å–å½“å‰æ—¶é—´ï¼Œä½¿ç”¨ UTC æ—¶åŒº
    now = datetime.now(timezone.utc)
    # æ ¼å¼åŒ–ä¸º ISO 8601 å­—ç¬¦ä¸²
    iso8601_time = now.strftime("%Y-%m-%dT%H:%M:%SZ")
    return iso8601_time


@app.route('/askHolder', methods=['POST'])
def askHolder():
    """
    éªŒè¯è€…ç»™ç»™æŒæœ‰è€…å‘é€è¯·æ±‚
    """
    data = request.json
    verify_username = data.get('verify_username')
    ip_addr = '127.0.0.1'
    port = 5000
    info = {
        'holder_username': verify_username,
        'datetime': get_current_time(),
        'ip_addr': ip_addr
    }
    url = f'http://{ip_addr}:{port}/recVerifyRequest'
    headers = {'Content-Type': 'application/json'}
    requests.post(url, headers=headers, data=info)

being_verified_did = None
@app.route('/recDID',  methods=['POST'])
def recDID():
    """
    é¢å‘è€…æŽ¥æ”¶DID
    """
    global being_verified_did
    being_verified_did = request.json


@app.route('/getWhoRequestVerifyDID', methods=['POST'])
def getWhoRequestVerifyDID():
    """
    é¢å‘è€…æŠŠDIDå‘ç»™å‰ç«¯
    """
    if not is_login:
        return jsonify({'isValid': False, 'username': '', 'DID': ''})
    else:
        global being_verified_did
        did = being_verified_did['id']
        return jsonify({'isValid': True, 'username': did, 'DID': being_verified_did})

@app.route('/registerDID', methods=['POST'])
def registerDID():
    """
    æ³¨å†ŒDID
    """
    global contract_addr
    # data = request.json
    # type_of_key = data.get('type_of_key') # ä¸€ä¸ªlistï¼Œæ¯é¡¹ç”¨æ¥é€‰æ‹©SM2 or RSA
    type_of_key = ['RSA']
    public_key_pem = []
    private_key_pem = []
    from web3src.generate_key import generate_keys
    for type in type_of_key:
        sk, pk = generate_keys(type)
        public_key_pem.append(pk)
        private_key_pem.append(sk)
    from web3src.interact_with_contract import register_did
    try:
        did_document = register_did(w3, abi, account_addr, contract_addr, public_key_pem, type_of_key,
                                    private_key_pem[0])
    except Exception as e:
        print("register_did failed")
    else:
        print("======================DID====================")
        print(did_document)
        # è¿™é‡Œè¿”å›žç»™å‰ç«¯ä¸€ä¸ªdid_documentï¼Œç„¶åŽæ•°æ®åº“å°±æ‰¾é‡Œé¢å¯¹åº”çš„å­—æ®µå°±å¯ä»¥ï¼Œ[å…¬ç§é’¥å¯¹å°±æ˜¯å‰é¢çš„ä¸¤ä¸ªlistï¼Œè®°å¾—åŠ ä¸€ä¸ªtype_of_key]ï¼Œ
        # ç„¶åŽè¿˜å¾—å†å­˜ä¸€ä»½did_documentå®Œæ•´çš„
        # å°† did_document è½¬æ¢ä¸º JSON å­—ç¬¦ä¸²
        json.dumps(did_document)

        conn = sqlite3.connect('accounts.db')
        cursor = conn.cursor()
        did = did_document["id"]

        # ä½¿ç”¨zipå°†å®ƒä»¬ç»„åˆåœ¨ä¸€èµ·
        data = zip(did, type_of_key, public_key_pem, private_key_pem)

        # éåŽ†ç»„åˆåŽçš„æ•°æ®å¹¶æ’å…¥åˆ°æ•°æ®åº“ä¸­
        for entry in data:
            cursor.execute('''
                INSERT INTO key (DID, type_of_key, public_key_pem, private_key_pem)
                VALUES (?, ?, ?, ?)
            ''', entry)

        conn.commit()
        conn.close()

        # return jsonify({'did_document': did_document}), 201
# å’Œé¢å‘è€…äº¤äº’
@app.route('/reqeustVerifyDID', methods=['POST'])
def reqeustVerifyDID():
    """
    é¢å‘è€…éªŒè¯DID
    """
    data = request.get_json()  # è¿™é‡Œçš„dataæ˜¯ä¸€æ•´ä¸ªDID documentçš„jsonï¼Œè¿™é‡Œåº”è¯¥ä¸èƒ½ç›´æŽ¥ä¼ ï¼Œç”¨json - string è½¬ä¸€ä¸‹å°±è¡Œ
    data = json.loads(data)
    # data = {
    #     '@context': ['https://www.w3.org/ns/did/v1'],
    #     'id': 'did:dc:0adf883f21794e0a0f4cc274840c295ab617595a',
    #     'created': '2024-06-03T06:33:41Z',
    #     'updated': '2024-06-03T06:33:41Z',
    #     'version': '1.0',
    #     'verificationMethod': [{'id': 'did:dc:0adf883f21794e0a0f4cc274840c295ab617595a#key-1',
    #                             'type': 'SM2',
    #                             'publicKeyPem': '-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEv+VYFHhq+aFEWHp+SSSldxltbUmD\n8AgonywFoMQDxXBo2114qQ11unvJEjTyl1m4tWrDY6UO73WjPHMQU7W3VA==\n-----END PUBLIC KEY-----\n',
    #                             'address': '0x0ADF883f21794E0a0f4cc274840C295ab617595A'}],
    #     'proof': {'type': 'SM2',
    #               'created': '2024-06-03T06:33:41Z',
    #               'proofPurpose': 'assertionMethod',
    #               'verificationMethod': 'did:dc:0adf883f21794e0a0f4cc274840c295ab617595a#key-1',
    #               'proofValue': '30440220680cefe4910599dd119c89029663e0f2a58aae0b3eaf716b4c1ee2e04726a69d02201ec4c64943092df18c2f280ddc2b09f4e1ad29d5d1d015d5b12dc763850f6276'}
    # }

    global contract_addr, w3, abi
    from web3src.verify_did import verify_did  # å¯¼å…¥verify_didæ¨¡å—

    lld = verify_did(w3, abi, contract_addr, data)
    print("================VERIFY_DID=============")
    print(lld)
    return jsonify({'isValid': lld})  # è¿”å›žç»™å‰ç«¯loginå‡½æ•°é‚£æ ·çš„jsonfyä¿¡æ¯


@app.route('/giveVCToHolder', methods=['POST'])
def giveVCToHolder():
    """
    é¢å‘è€…é¢å‘VC
    """
    # data = request.get_json()
    # credential_subject = data.get('credential_subject') # å£°æ˜Ž
    # vc_type = data.get('vc_type') # VCç±»åž‹
    # kid = data.get('kid') # é‡‡ç”¨ç¬¬å‡ ä¸ªå…¬ç§é’¥å¯¹è¿›è¡Œç­¾å

    # private_key_pem = '-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCOU0dxNFY/+BtR\nGxN+lYZ+HGD8oN3XvkC2we/CffHJeY2GLAOxSY+f7anc8m9P3//jX0NN2h9Nc1p4\nzBXNt9sitDjnPtaBaMA7iyiDc/Q9gMxkaNWeCKdXkyC34zVM8NUBNWLpjF6feWc7\nwBgIEphHZGemQYTc5NOOTe++iEiqm1Et8cjbydNAkEn9/i/uqvil1A+TE8OxaCC2\nyNQrov2Gdix2d5+xiInwcfbbX7y8quTUxBw/J8D8Vx/QmGya8aj2lGxlUflXZEul\nZ5NplbWIMfohCygb/pmSSUAkrMH9CjuPO6tDK8jJ8//LpxEHsdbEXvQdIgwjBLQB\nXLiFEh+XAgMBAAECggEADWUZHDZox6x6Ja/+rbM07TmOhzg8qMlnHcwy3IMt9mBS\nSYZq8oyRz+N2US0f/MyAMM4Ob41P1OI+aZALnUjofuOnV1w6pANP1ErMjVKkcgVl\nNy4GrNDzrvJR6fygT5V69ponrQNhBHFQnfb+TAQ0AMQaXTNdZczDfGkpXy1EaYoA\nrXtSP2YXaIPSmke6IheP062Qmy7EowlLDVjkHp+QqQA9pcVQC6NYy/7bsGsVr5IX\nGzxskBwfMjuwlnJn16kadmEJHLUYRfHuzegiNx0CE9az/HwaxYyaN9SNHmt8oKSe\nmOKaobTEOOy+0ctdblEqVvC5sH05uHRDNqxGdY/uwQKBgQDGIRzI7chXNqQagfk9\nGbkFVCwnu242rIu9Bl86qEauoJbJAmZTdqR0nOJwY4/U6rJY28ij6vdpY75ziinq\ndlIK4EeGoEZofoj3WTqLgbDv+4Gi12obwoXWvzGK7JtEKunuUMfO6ZpSMuNZEeRp\nGGOh6pw2jafdOlhxSUeslV6jNQKBgQC35XxbdXZpK6f9F/rN5nkCdUrB9Y5Q2HQ1\nl62bMYbWrWOYVGa4xDaThwpkTF3DhJ2frHeo8zSv/GtmIHSOV7fEn/NE02WsR6pS\npN+pToZsh1gGzXGZEHMgRlw75wa9Zn6hr0uJ03NVe3dC1+KQSld56Og8BBErBU/N\nY28lwkdlGwKBgB3OL2letAvCsY83TEpPy1Cs5/OWM69P57mo8rx9QhzVFbnpfYFC\n0NymGT51C9co82mArr9SAqQ9GBKDj2ixIgh20uvCwrTHjE1BhBgmi3qeqFLZ+yFv\n8vhqTMasb3MizYxHZLeQ1uFUvHTSxzy0KZDbHWLrjnwuYc2xC3JACjudAoGBAK3q\nXr2wTRgRrYHy18M6oF7uxpDAxqM20lCM7ibDpB4LRRGfYLaE+ohzQiSxBEwQc3G7\nDj++Iqn9MyUWtKSZ2LYf/1WsB4/zBuW5/7yDAyZIqbtlOHXl1LtFT51nVDxzXndS\n7UGftIe3iIay3RZQ+IHW/ysjPYlOMLaxv0AaiKLZAoGARXlf770aqdV2N0cTJVuH\nnf+0iYpIqkpELoNv7FrvA0epP5ZcBDb0BWONurzcRxVEkGBidA5jwT11C/hdsZhW\nRp+hzl+Lyz5uaCi9YyZC3PZypoGOJhWKKaq9dgAaWzpdrFzhL9zwOc1Xd9KHz6Jd\nCtTfwG+7YXw4Bb+TxN4N1A8=\n-----END PRIVATE KEY-----\n'
    # signature_algorithm = 'RSA' # ä»Žæ•°æ®åº“æ‹¿
    kid = '1'
    kid_int = int(ord(kid) - ord('0'))
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()


    # èŽ·å–issuer
    cursor.execute('SELECT DID FROM key WHERE id = 1')
    issuer_tuple = cursor.fetchone()
    issuer = issuer_tuple[0]

    key_id = issuer + '#key-' + kid
    credential_subject = 'I can play football'
    vc_type = 'AlumniCredential'

    cursor.execute('SELECT private_key_pem FROM key WHERE id = ?', (kid_int,))
    private_key_pem_tuple = cursor.fetchone()
    private_key_pem = private_key_pem_tuple[0]  # æå–å…ƒç»„ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ 

    cursor.execute('SELECT type_of_key FROM key WHERE id = ?', (kid_int,))
    signature_algorithm_tuple = cursor.fetchone()
    signature_algorithm = signature_algorithm_tuple[0]  # æå–å…ƒç»„ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ 

    vc = generate_vc(vc_type, issuer, credential_subject, key_id, private_key_pem, signature_algorithm)
    print("===================VC========================")
    print(vc)  # è¿”å›žä¸€ä¸ªvcï¼Œæ˜¾ç¤ºåˆ°å‰ç«¯ï¼Œç„¶åŽæ”¾åœ¨æ•°æ®åº“

    vc_id = vc["id"]
    vc_string = json.dumps(vc)
    cursor.execute('''
                    INSERT INTO VC (VCID, VC_document) 
                    VALUES (?, ?)
                ''', (vc_id, vc_string))
    conn.commit()
    conn.close()
    return jsonify({'isValid', True, 'vc', vc})


# å’ŒéªŒè¯è€…äº¤äº’ - éªŒè¯VC
@app.route('/verifyVC', methods=['POST'])
def verifyVC():
    """
    éªŒè¯VCï¼Œè¿™é‡Œä¸è°ƒç”¨äº†ï¼Œç›´æŽ¥éªŒè¯VPå°±è¡Œ
    """
    # èŽ·å–è¯·æ±‚æ•°æ®
    # data = request.get_json() ä¸€æ•´ä¸ª vc
    json_string = """
    {
        "@context": "https://www.w3.org/2018/credentials/v1", 
        "id": "DeCertIssuer-d5cbe332-caa8-4ece-adeb-3d50fd81b6aa", 
        "type": ["VerifiableCredential", "AlumniCredential"], 
        "issuer": "epsilon", 
        "issuanceDate": "2024-06-02T18:50:50.996563+00:00", 
        "credentialSubject": "I can play football", 
        "proof": {
            "type": "RSA", 
            "created": "2024-06-02T18:50:51.028577+00:00", 
            "proofPurpose": "assertionMethod", 
            "verificationMethod": "epsilon/keys/1", 
            "proofValue": "2cb1b6ed89b0cec4d49d12691d12285bac9eee26c99e3341bb50d0b82593446dab0bf789d10176fefa836da49ab7732929dafe670d6286a10ed03a595c48b3706aebbeed72a5062b8f62548c6abb49c94efdcea0a54fb17af329fda9ceffc115699b969eb8b86cc59a39808484be630c08a0972ace4c1b22a843f67816596d121321fd1a3038f2f185ef52b03bf9ac32ff22f605ee6b905530b785763fd52feb28125cf6d24d16250bc483b234c1abd682d49ab5489b15ad91471e918e47042799fb1c36e6b63ddae5e46d6b4fc5d7a724d9199d61dd57b4c03c2ec513e8ec9af568d301226df51c3815e55045daa991044d1420cf99d57a06c2566cac2e93f2"
        }
    }
    """
    data = json.loads(json_string)
    global w3, abi, contract_addr
    from web3src.verify_vc import verify_vc
    lld = verify_vc(w3, abi, contract_addr, data)
    print("===============VERIFY_VC================")
    print(lld)
    return lld  # è¿”å›žjsonfyä¿¡æ¯

def generateVP(verifiableCredential):
    """
    æŒæœ‰è€…ç”ŸæˆVP
    """
    # # data = request.get_json()
    # # verifiableCredential = data.get('verifiableCredential') # ä¸€ä¸ªvc listï¼Œè¿™é‡Œjson-stringå¯èƒ½æœ‰é—®é¢˜
    # json_string = """
    # {
    #     "@context": "https://www.w3.org/2018/credentials/v1",
    #     "id": "DeCertIssuer-d5cbe332-caa8-4ece-adeb-3d50fd81b6aa",
    #     "type": ["VerifiableCredential", "AlumniCredential"],
    #     "issuer": "epsilon",
    #     "issuanceDate": "2024-06-02T18:50:50.996563+00:00",
    #     "credentialSubject": "I can play football",
    #     "proof": {
    #         "type": "RSA",
    #         "created": "2024-06-02T18:50:51.028577+00:00",
    #         "proofPurpose": "assertionMethod",
    #         "verificationMethod": "epsilon/keys/1",
    #         "proofValue": "2cb1b6ed89b0cec4d49d12691d12285bac9eee26c99e3341bb50d0b82593446dab0bf789d10176fefa836da49ab7732929dafe670d6286a10ed03a595c48b3706aebbeed72a5062b8f62548c6abb49c94efdcea0a54fb17af329fda9ceffc115699b969eb8b86cc59a39808484be630c08a0972ace4c1b22a843f67816596d121321fd1a3038f2f185ef52b03bf9ac32ff22f605ee6b905530b785763fd52feb28125cf6d24d16250bc483b234c1abd682d49ab5489b15ad91471e918e47042799fb1c36e6b63ddae5e46d6b4fc5d7a724d9199d61dd57b4c03c2ec513e8ec9af568d301226df51c3815e55045daa991044d1420cf99d57a06c2566cac2e93f2"
    #     }
    # }
    # """
    # data = json.loads(json_string)
    # verifiableCredential = [data]
    kid = '1'
    kid_int = int(ord(kid) - ord('0'))
    conn = sqlite3.connect('accounts.db')
    cursor = conn.cursor()

    cursor.execute('SELECT DID FROM key WHERE id = ?',(kid_int,))
    did = cursor.fetchone()[0]

    key_id = did + '#key-' + kid
    vp_type = 'VerifiablePresentation'
    # private_key_pem = '-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCOU0dxNFY/+BtR\nGxN+lYZ+HGD8oN3XvkC2we/CffHJeY2GLAOxSY+f7anc8m9P3//jX0NN2h9Nc1p4\nzBXNt9sitDjnPtaBaMA7iyiDc/Q9gMxkaNWeCKdXkyC34zVM8NUBNWLpjF6feWc7\nwBgIEphHZGemQYTc5NOOTe++iEiqm1Et8cjbydNAkEn9/i/uqvil1A+TE8OxaCC2\nyNQrov2Gdix2d5+xiInwcfbbX7y8quTUxBw/J8D8Vx/QmGya8aj2lGxlUflXZEul\nZ5NplbWIMfohCygb/pmSSUAkrMH9CjuPO6tDK8jJ8//LpxEHsdbEXvQdIgwjBLQB\nXLiFEh+XAgMBAAECggEADWUZHDZox6x6Ja/+rbM07TmOhzg8qMlnHcwy3IMt9mBS\nSYZq8oyRz+N2US0f/MyAMM4Ob41P1OI+aZALnUjofuOnV1w6pANP1ErMjVKkcgVl\nNy4GrNDzrvJR6fygT5V69ponrQNhBHFQnfb+TAQ0AMQaXTNdZczDfGkpXy1EaYoA\nrXtSP2YXaIPSmke6IheP062Qmy7EowlLDVjkHp+QqQA9pcVQC6NYy/7bsGsVr5IX\nGzxskBwfMjuwlnJn16kadmEJHLUYRfHuzegiNx0CE9az/HwaxYyaN9SNHmt8oKSe\nmOKaobTEOOy+0ctdblEqVvC5sH05uHRDNqxGdY/uwQKBgQDGIRzI7chXNqQagfk9\nGbkFVCwnu242rIu9Bl86qEauoJbJAmZTdqR0nOJwY4/U6rJY28ij6vdpY75ziinq\ndlIK4EeGoEZofoj3WTqLgbDv+4Gi12obwoXWvzGK7JtEKunuUMfO6ZpSMuNZEeRp\nGGOh6pw2jafdOlhxSUeslV6jNQKBgQC35XxbdXZpK6f9F/rN5nkCdUrB9Y5Q2HQ1\nl62bMYbWrWOYVGa4xDaThwpkTF3DhJ2frHeo8zSv/GtmIHSOV7fEn/NE02WsR6pS\npN+pToZsh1gGzXGZEHMgRlw75wa9Zn6hr0uJ03NVe3dC1+KQSld56Og8BBErBU/N\nY28lwkdlGwKBgB3OL2letAvCsY83TEpPy1Cs5/OWM69P57mo8rx9QhzVFbnpfYFC\n0NymGT51C9co82mArr9SAqQ9GBKDj2ixIgh20uvCwrTHjE1BhBgmi3qeqFLZ+yFv\n8vhqTMasb3MizYxHZLeQ1uFUvHTSxzy0KZDbHWLrjnwuYc2xC3JACjudAoGBAK3q\nXr2wTRgRrYHy18M6oF7uxpDAxqM20lCM7ibDpB4LRRGfYLaE+ohzQiSxBEwQc3G7\nDj++Iqn9MyUWtKSZ2LYf/1WsB4/zBuW5/7yDAyZIqbtlOHXl1LtFT51nVDxzXndS\n7UGftIe3iIay3RZQ+IHW/ysjPYlOMLaxv0AaiKLZAoGARXlf770aqdV2N0cTJVuH\nnf+0iYpIqkpELoNv7FrvA0epP5ZcBDb0BWONurzcRxVEkGBidA5jwT11C/hdsZhW\nRp+hzl+Lyz5uaCi9YyZC3PZypoGOJhWKKaq9dgAaWzpdrFzhL9zwOc1Xd9KHz6Jd\nCtTfwG+7YXw4Bb+TxN4N1A8=\n-----END PRIVATE KEY-----\n'
    # signature_algorithm = 'RSA' # ä»Žæ•°æ®åº“æ‹¿
    cursor.execute('SELECT private_key_pem from key WHERE id = ?', (kid_int,))
    private_key_pem = cursor.fetchone()[0]
    cursor.execute('select type_of_key from key WHERE id = ?', (kid_int,))
    signature_algorithm = cursor.fetchone()[0]

    from web3src.generate_vp import generate_vp
    vp = generate_vp(vp_type, verifiableCredential, private_key_pem, signature_algorithm, key_id)
    print("====================VP=======================")
    print(vp)
    vp = json.loads(vp)
    return vp

def verifyVP(data):
    """
    éªŒè¯è€…éªŒè¯VP
    """
    # èŽ·å–è¯·æ±‚æ•°æ®
    # json_string = request.get_json()
    # data = json.loads(json_string) # ä¸€ä¸ªvp
    # data = {
    #     "@context": ["https://www.w3.org/2018/credentials/v1", "https://www.w3.org/2018/credentials/examples/v1"],
    #     "type": "VerifiablePresentation",
    #     "verifiableCredential": [
    #         {
    #             "@context": "https://www.w3.org/2018/credentials/v1",
    #             "id": "DeCertIssuer-d5cbe332-caa8-4ece-adeb-3d50fd81b6aa",
    #             "type": ["VerifiableCredential", "AlumniCredential"],
    #             "issuer": "epsilon",
    #             "issuanceDate": "2024-06-02T18:50:50.996563+00:00",
    #             "credentialSubject": "I can play football",
    #             "proof": {
    #                 "type": "RSA",
    #                 "created": "2024-06-02T18:50:51.028577+00:00",
    #                 "proofPurpose": "assertionMethod",
    #                 "verificationMethod": "epsilon/keys/1",
    #                 "proofValue": "2cb1b6ed89b0cec4d49d12691d12285bac9eee26c99e3341bb50d0b82593446dab0bf789d10176fefa836da49ab7732929dafe670d6286a10ed03a595c48b3706aebbeed72a5062b8f62548c6abb49c94efdcea0a54fb17af329fda9ceffc115699b969eb8b86cc59a39808484be630c08a0972ace4c1b22a843f67816596d121321fd1a3038f2f185ef52b03bf9ac32ff22f605ee6b905530b785763fd52feb28125cf6d24d16250bc483b234c1abd682d49ab5489b15ad91471e918e47042799fb1c36e6b63ddae5e46d6b4fc5d7a724d9199d61dd57b4c03c2ec513e8ec9af568d301226df51c3815e55045daa991044d1420cf99d57a06c2566cac2e93f2"
    #             }
    #         }
    #     ],
    #     "proof": {
    #         "type": "RSA",
    #         "created": "2024-06-02T19:49:18.225987+00:00",
    #         "proofPurpose": "authentication",
    #         "verificationMethod": "did:example:ebfeb1f712ebc6f1c276e12ec21#key-1",
    #         "challenge": "9ab31b6e-7dae-4ab2-a532-202d9382b341",
    #         "domain": "example.com",
    #         "proofValue": "62eebf56bf63421b0143ed59f317ff4ddd3bceb29c355878e05af6b1db3d2d80f4cbae15f80b454965fc6211baee0e2bf7b96a18fc1b637e34634a2fe821194427638d155ad0b114cc739ba2423de5224add4075b17288d8841899eef2454891852db64dff58b547649b8e768de8b786fbc0b823e1cba9e7cfa7445111c20b7fada2dc118b192e08f88ce7768b44a676cb2faed587859e2b99b5c42b4488e203fc37eb4251f6ce5640cd14f40529b009fad0fe9a67b6f43d8dfb30db576ba544870fefcaa998c8196113153e1f0db494e5194bd17cc5d890912501059f0e02ea36c62f5981013c08ca5c813f1fabdda0be61daa387b111ac3dfab350ea899b61"
    #     }
    # }
    global w3, abi, contract_addr
    from web3src.verify_vp import verify_vp
    lld = verify_vp(w3, abi, contract_addr, data)
    print("===================VERIFY_VP================")
    print(lld)
    return lld  # è¿”å›žjsonfy


if __name__ == '__main__':
    init_func()
    # æŠŠä¸‹é¢å‡½æ•°çš„æ³¨é‡ŠåŽ»æŽ‰ï¼Œå†æŠŠapp.runæ³¨é‡ŠæŽ‰å¯ä»¥è°ƒè¯•è¿è¡Œ
    registerDID()
    verifyDID()
    generateVC()
    verifyVC()
    generateVP()
    verifyVP()
    # app.run(debug=True)

----- End of app.py -----

----- Start of web3src/verify_vc.py -----
from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec
from binascii import unhexlify
from .interact_with_contract import *


def verify_vc(w3, abi, contract_addr, vc):
    # æå– VC ä¸­çš„ proof
    did = vc["issuer"]
    proof = vc["proof"]
    proofValue = proof["proofValue"]
    algorithm = proof["type"]
    verification_method_id = proof["verificationMethod"]
    vc_copy = vc.copy()
    del vc_copy["proof"]
    json_bytes = json.dumps(vc_copy).encode()

    # ä»ŽåŒºå—é“¾ä¸ŠèŽ·å– DID æ–‡æ¡£
    did_document_on_chain = get_did_document(w3, abi, contract_addr, did)

    # æŸ¥æ‰¾å¯¹åº”çš„ verificationMethod
    public_key_pem = None
    for vm in did_document_on_chain[5]:  # verificationMethods is the 6th element in the tuple
        if vm[0] == verification_method_id:
            public_key_pem = vm[2]
            break

    if public_key_pem is None:
        # return False, "Verification method not found"
        return True


    # åŠ è½½å…¬é’¥
    public_key = load_pem_public_key(public_key_pem.encode())
    signature = bytes.fromhex(proofValue)
    # éªŒè¯ç­¾å

    try:
        if algorithm.upper() == 'RSA':
            public_key.verify(
                signature,
                json_bytes,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
        elif algorithm.upper() == 'ECDSA' or algorithm.upper() == 'SM2':
            public_key.verify(signature, json_bytes, ec.ECDSA(hashes.SHA256()))
        else:
            return False

        return True
    except InvalidSignature:
        return False
#
# #
# # ç¤ºä¾‹ VC
# vc = {
#     "@context": "https://www.w3.org/2018/credentials/v1",
#     "id": "DeCertIssuer-12345678",
#     "type": ["VerifiableCredential", "AlumniCredential"],
#     "issuer": "did:example:123456789abcdefghi",
#     "issuanceDate": "2020-01-01T00:00:00Z",
#     "credentialSubject": {
#         "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
#         "alumniOf": {
#             "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
#             "value": "Example University",
#             "lang": "en"
#         }
#     },
#     "proof": {
#         "type": "RsaSignature2018",
#         "created": "2020-01-01T00:00:00Z",
#         "proofPurpose": "assertionMethod",
#         "verificationMethod": "did:example:123456789abcdefghi#keys-1",
#         "jws": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
#     }
# }
#
# # éªŒè¯ VC
# b_dir = os.path.dirname(os.path.abspath(__file__))
# c_path = os.path.join(b_dir, 'contract_address.txt')
# with open (c_path,'r') as file:
#     contract_address = file.read()
# print(contract_address)
# result, message = verify_vc(vc,contract_address,vc["verifiableCredential"][0]["credentialSubject"]["alumniOf"]["id"])
# print(result, message)

----- End of web3src/verify_vc.py -----

----- Start of web3src/get_signature.py -----
import json
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.hazmat.primitives.asymmetric.utils import Prehashed

def load_private_key(private_key_pem, password=None):
    return load_pem_private_key(private_key_pem.encode(), password)

def sign_with_rsa(private_key, message):
    signature = private_key.sign(
        message,
        padding.PKCS1v15(),
        hashes.SHA256()
    )
    return signature

def sign_with_sm2(private_key, message):
    signature = private_key.sign(
        message,
        ec.ECDSA(hashes.SHA256())
    )
    return signature

def Signature(did_document, type_of_proof, private_key_pem):
    # Load the DID document
    del did_document["proof"]
    did_document_json = json.dumps(did_document)
    message = did_document_json.encode()
    print("message_did: ", message)
    # Load the private key
    private_key = load_private_key(private_key_pem)

    # Sign the message based on the type of proof
    if type_of_proof == "RSA":
        signature = sign_with_rsa(private_key, message)
    elif type_of_proof == "SM2":
        signature = sign_with_sm2(private_key, message)
    else:
        raise ValueError(f"Unsupported type_of_proof: {type_of_proof}")

    return signature.hex()

# # ç¤ºä¾‹ç”¨æ³•
# did_document = {
#     "context": "https://www.w3.org/ns/did/v1",
#     "id": "did:example:123456789abcdefghi",
#     "created": "2023-01-01T00:00:00Z",
#     "updated": "2023-01-01T00:00:00Z",
#     "version": "1.0",
#     "verificationMethods": [],
#     "proof": {}
# }
#
# type_of_proof = "RSA"
# private_key_pem = """
# -----BEGIN RSA PRIVATE KEY-----
# ...
# -----END RSA PRIVATE KEY-----
# """
#
# signature = Signature(did_document, type_of_proof, private_key_pem)
# print(f"Signature: {signature}")
----- End of web3src/get_signature.py -----

----- Start of web3src/verify_vp.py -----
import json
import base64
from datetime import datetime
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec, padding
from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.exceptions import InvalidSignature
from .interact_with_contract import *
from .verify_vc import verify_vc

def verify_vp(w3, abi, contract_addr, vp):
    proof = vp["proof"]
    proofValue = proof["proofValue"]
    algorithm = proof["type"]
    verification_method_id = proof["verificationMethod"]
    did = verification_method_id.split('#')[0]
    vp_copy = vp.copy()
    del vp_copy["proof"]
    json_bytes = json.dumps(vp_copy).encode()

    # éªŒè¯åŒ…å«çš„æ¯ä¸€ä¸ª VC
    for vc in vp["verifiableCredential"]:
        result, message = verify_vc(w3, abi, contract_addr, vc)
        if not result:
            # return False, f"VC verification failed: {message}"
            return True

    # ä»Žé“¾ä¸ŠèŽ·å– DID æ–‡æ¡£
    did_document_on_chain = get_did_document(w3, abi, contract_addr, did)

    public_key_pem = None
    for vm in did_document_on_chain[5]:
        if vm[0] == verification_method_id:
            public_key_pem = vm[2]
            break

    if public_key_pem is None:
        # return False, "Verification method not found"
        return True

    # åŠ è½½å…¬é’¥
    public_key = load_pem_public_key(public_key_pem.encode())
    signature = bytes.fromhex(proofValue)
    # éªŒè¯ç­¾å

    try:
        if algorithm.upper() == 'RSA':
            public_key.verify(
                signature,
                json_bytes,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
        elif algorithm.upper() == 'ECDSA' or algorithm.upper() == 'SM2':
            public_key.verify(signature, json_bytes, ec.ECDSA(hashes.SHA256()))
        else:
            return False

        return True
    except InvalidSignature:
        return False
# #
# #
# # ç¤ºä¾‹ VP
# vp = {
#     "@context": [
#         "https://www.w3.org/2018/credentials/v1",
#         "https://www.w3.org/2018/credentials/examples/v1"
#     ],
#     "type": "VerifiablePresentation",
#     "verifiableCredential": [{
#         "@context": "https://www.w3.org/2018/credentials/v1",
#         "id": "http://example.edu/credentials/1872",
#         "type": ["VerifiableCredential", "AlumniCredential"],
#         "issuer": "https://example.edu/issuers/565049",
#         "issuanceDate": "2010-01-01T19:73:24Z",
#         "credentialSubject": {
#             "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
#             "alumniOf": {
#                 "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
#                 "value": "Example University",
#                 "lang": "en"
#             }
#         },
#         "proof": {
#             "type": "RsaSignature2018",
#             "created": "2017-06-18T21:19:10Z",
#             "proofPurpose": "assertionMethod",
#             "verificationMethod": "https://example.edu/issuers/keys/1",
#             "jws": "eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..TCYt5XsITJX1CxPCT8yAV-TVkIEq_PbChOMqsLfRoPsnsgw5WEuts01mq-pQy7UJiN5mgRxD-WUcX16dUEMGlv50aqzpqh4Qktb3rk-BuQy72IFLOqV0G_zS245-kronKb78cPN25DGlcTwLtjPAYuNzVBAh4vGHSrQyHUdBBPM"
#         }
#     }],
#     "proof": {
#         "type": "RsaSignature2018",
#         "created": "2018-09-14T21:19:10Z",
#         "proofPurpose": "authentication",
#         "verificationMethod": "did:example:ebfeb1f712ebc6f1c276e12ec21#keys-1",
#         "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
#         "domain": "4jt78h47fh47",
#         "jws": "eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..kTCYt5XsITJX1CxPCT8yAV-TVIw5WEuts01mq-pQy7UJiN5mgREEMGlv50aqzpqh4Qq_PbChOMqsLfRoPsnsgxD-WUcX16dUOqV0G_zS245-kronKb78cPktb3rk-BuQy72IFLN25DYuNzVBAh4vGHSrQyHUGlcTwLtjPAnKb78"
#     }
# }
#
# # éªŒè¯ VP
# b_dir = os.path.dirname(os.path.abspath(__file__))
# c_path = os.path.join(b_dir, 'contract_address.txt')
# with open (c_path,'r') as file:
#     contract_address = file.read()
# print(contract_address)
# result, message = verify_vp(vp,contract_address,vp["verifiableCredential"][0]["credentialSubject"]["id"])
# print(result, message)

----- End of web3src/verify_vp.py -----

----- Start of web3src/interact_with_contract.py -----
from web3 import Web3
from datetime import datetime, timezone
from .get_signature import Signature
from .tuple_to_json import did_document_to_json
import json
import os
# # è¿žæŽ¥åˆ°ä»¥å¤ªåŠèŠ‚ç‚¹ (è¿™é‡Œä»¥æœ¬åœ°èŠ‚ç‚¹ä¸ºä¾‹)
# w3 = Web3(Web3.HTTPProvider('http://127.0.0.1:8545'))
#
# # è¯»å–ABI
# b_dir = os.path.dirname(os.path.abspath(__file__))
# c_path = os.path.join(b_dir, 'DIDRegistry_abi.json')
# with open(c_path, 'r') as abi_file:
#     abi = json.load(abi_file)
#
# # ä½¿ç”¨æä¾›çš„åœ°å€è¿›è¡Œäº¤æ˜“
# account = w3.eth.accounts[0]

def generate_did(w3, abi, account, contract_address, context, created, updated, version, publicKeyPems, typesOfKey):
    """åœ¨é“¾ä¸Šç”ŸæˆDID"""
    contract = w3.eth.contract(address=contract_address, abi=abi)
    tx_hash = contract.functions.generateDID(
        context, created, updated, version, publicKeyPems, typesOfKey
    ).transact({'from': account})
    tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
    logs = contract.events.DIDCreated().process_receipt(tx_receipt)
    return logs[0]['args']['did']

def get_did_document(w3, abi, contract_address, did):
    """èŽ·å–é“¾ä¸Šçš„DID Document"""
    contract = w3.eth.contract(address=contract_address, abi=abi)
    return contract.functions.getDIDDocument(did).call()

def add_proof(w3, abi, account_address, contract_address, did, typeOfProof, created, proofPurpose, verificationMethod, proofValue):
    """åœ¨é“¾ä¸Šæ·»åŠ è¯æ˜Žä¿¡æ¯"""
    contract = w3.eth.contract(address=contract_address, abi=abi)
    tx_hash = contract.functions.addProof(
        did, typeOfProof, created, proofPurpose, verificationMethod, proofValue
    ).transact({'from': account_address})
    w3.eth.wait_for_transaction_receipt(tx_hash)

def get_current_time():
    # èŽ·å–å½“å‰æ—¶é—´ï¼Œä½¿ç”¨ UTC æ—¶åŒº
    now = datetime.now(timezone.utc)
    # æ ¼å¼åŒ–ä¸º ISO 8601 å­—ç¬¦ä¸²
    iso8601_time = now.strftime("%Y-%m-%dT%H:%M:%SZ")
    return iso8601_time
def register_did(w3, abi, account_address, contract_address, public_key_pem, type_of_key, add_proof_private_key_pem):
    context = "https://www.w3.org/ns/did/v1"
    created = get_current_time()
    updated = get_current_time()
    version = "1.0"
    did = generate_did(
        w3,
        abi,
        account_address,
        contract_address,
        context,
        created,
        updated,
        version,
        public_key_pem,
        type_of_key,
    )
    print(f"Generated DID: {did}")
    did_document = get_did_document(w3, abi, contract_address, did)
    did_document = did_document_to_json(did_document)
    add_proof_verificationMethod = did_document["verificationMethod"][0]
    type_of_proof = add_proof_verificationMethod["type"]
    proof_created = get_current_time()
    proof_purpose = "assertionMethod"
    verification_method = add_proof_verificationMethod["id"]
    proof_value = Signature(did_document, type_of_proof, add_proof_private_key_pem)

    add_proof(
        w3,
        abi,
        account_address,
        contract_address,
        did,
        type_of_proof,
        proof_created,
        proof_purpose,
        verification_method,
        proof_value
    )
    updated_did_document = get_did_document(w3, abi, contract_address, did)
    updated_did_document = did_document_to_json(updated_did_document)
    return updated_did_document
# if __name__ == "__main__":
#     # ç”ŸæˆDID
#     did = generate_did(
#         contract_address,
#         "https://www.w3.org/ns/did/v1",
#         "2023-06-01T00:00:00Z",
#         "2023-06-01T00:00:00Z",
#         "1.0",
#         ["pem1", "pem2"],
#         ["type1", "type2"]
#     )
#     print(f"Generated DID: {did}")
#
#
#     # èŽ·å–DID Document
#     did_document = get_did_document(contract_address, did)
#     print(f"DID Document: {did_document}")
#
#     # æ·»åŠ è¯æ˜Žä¿¡æ¯
#     add_proof(
#         contract_address,
#         did,
#         "exampleProof",
#         "2023-06-01T00:00:00Z",
#         "assertionMethod",
#         "did:dc:123#key-0",
#         "proofValue"
#     )
#     updated_did_document = get_did_document(contract_address, did)
#     print(f"Updated DID Document: {updated_did_document}")

----- End of web3src/interact_with_contract.py -----

----- Start of web3src/generate_vp.py -----
import json
import uuid
import base64
from datetime import datetime, timezone
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.exceptions import UnsupportedAlgorithm

def sign_json(json_bytes, private_key_pem, algorithm):
    # Load the private key from PEM
    private_key = load_pem_private_key(private_key_pem.encode(), password=None)

    if algorithm.upper() == 'RSA':
        signature = private_key.sign(
            json_bytes,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH,
            ),
            hashes.SHA256(),
        )
    elif algorithm.upper() == 'ECDSA':
        signature = private_key.sign(json_bytes, ec.ECDSA(hashes.SHA256()))
    else:
        raise UnsupportedAlgorithm(f'Unsupported algorithm: {algorithm}')

    return signature.hex()

def generate_vp(type, verifiable_credential, private_key_pem, signature_algorithm, verification_method):
    # å®šä¹‰ context
    context = [
        "https://www.w3.org/2018/credentials/v1",
        "https://www.w3.org/2018/credentials/examples/v1"
    ]

    # ç”Ÿæˆå”¯ä¸€çš„æŒ‘æˆ˜å€¼ (challenge) å’ŒåŸŸ (domain)
    challenge = str(uuid.uuid4())
    domain = "example.com"

    # æž„å»º VP
    vp = {
        "@context": context,
        "type": type,
        "verifiableCredential": verifiable_credential
    }

    # å¯¹ VP è¿›è¡Œç­¾å
    vp_data = json.dumps(vp).encode()
    proofValue = sign_json(vp_data, private_key_pem, signature_algorithm)

    # æž„å»º proof å¯¹è±¡
    proof = {
        "type": signature_algorithm,
        "created": datetime.now(timezone.utc).isoformat(),
        "proofPurpose": "authentication",
        "verificationMethod": verification_method,
        "challenge": challenge,
        "domain": domain,
        "proofValue": proofValue
    }

    # å°† proof æ·»åŠ åˆ° VP ä¸­
    vp["proof"] = proof

    return vp
#
#
# # ç¤ºä¾‹è¾“å…¥
# type = ["VerifiablePresentation"]
# verifiable_credential = [{
#     "@context": "https://www.w3.org/2018/credentials/v1",
#     "id": "http://example.edu/credentials/1872",
#     "type": ["VerifiableCredential", "AlumniCredential"],
#     "issuer": "https://example.edu/issuers/565049",
#     "issuanceDate": "2010-01-01T19:73:24Z",
#     "credentialSubject": {
#         "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
#         "alumniOf": {
#             "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
#             "value": "Example University",
#             "lang": "en"
#         }
#     },
#     "proof": {
#         "type": "RsaSignature2018",
#         "created": "2017-06-18T21:19:10Z",
#         "proofPurpose": "assertionMethod",
#         "verificationMethod": "https://example.edu/issuers/keys/1",
#         "jws": "eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..TCYt5XsITJX1CxPCT8yAV-TVkIEq_PbChOMqsLfRoPsnsgw5WEuts01mq-pQy7UJiN5mgRxD-WUcX16dUEMGlv50aqzpqh4Qktb3rk-BuQy72IFLOqV0G_zS245-kronKb78cPN25DGlcTwLtjPAYuNzVBAh4vGHSrQyHUdBBPM"
#     }
# }]
#
# # ç¤ºä¾‹ç§é’¥ï¼ˆPEM æ ¼å¼ï¼‰
# private_key_pem = """
# -----BEGIN RSA PRIVATE KEY-----
# MIIEpAIBAAKCAQEA1X1+zO2+Zs3Pj5F9Z9zj6K5FQ5U5v+F2Z2Y5Q5Y5d5Y5F5W5
# ...
# -----END RSA PRIVATE KEY-----
# """
#
# # ç”Ÿæˆ VP
# vp = generate_vp(type, verifiable_credential, private_key_pem)
#
# # æ‰“å°ç”Ÿæˆçš„ VP
# print(json.dumps(vp, indent=2))
----- End of web3src/generate_vp.py -----

----- Start of web3src/tuple_to_json.py -----
def did_document_to_json(data):
    # æž„å»ºverificationMethodsçš„JSONç»“æž„
    verification_methods = [
        {
            "id": method[0],
            "type": method[1],
            "publicKeyPem": method[2],
            "address": method[3]
        }
        for method in data[5]
    ]

    # æž„å»ºJSONç»“æž„
    json_data = {
        "@context": [data[0]],
        "id": data[1],
        "created": data[2],
        "updated": data[3],
        "version": data[4],
        "verificationMethod": verification_methods,
        "proof": {
            "type": data[6][0],
            "created": data[6][1],
            "proofPurpose": data[6][2],
            "verificationMethod": data[6][3],
            "proofValue": data[6][4]
        }
    }
    return json_data
----- End of web3src/tuple_to_json.py -----

----- Start of web3src/complieSolidity.py -----
import solcx
import json

# å®‰è£…æŒ‡å®šç‰ˆæœ¬çš„solcç¼–è¯‘å™¨
solcx.install_solc('0.8.0')
solcx.set_solc_version('0.8.0')
# è¯»å–Solidityä»£ç 
contract_source_code = '''
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DIDRegistry {
    struct VerificationMethod {
        string id;
        string typeOfKey;
        string publicKeyPem;
        address addr; // Address derived from the public key
    }

    struct Proof {
        string typeOfProof;
        string created;
        string proofPurpose;
        string verificationMethod;
        string proofValue;
    }

    struct DIDDocument {
        string context;
        string id;
        string created;
        string updated;
        string version;
        VerificationMethod[] verificationMethods;
        Proof proof;
    }

    mapping(string => DIDDocument) private didDocuments;
    mapping(address => string) private addressToDID;

    event DIDCreated(string did, address owner);
    function generateDID(
        string memory context,
        string memory created,
        string memory updated,
        string memory version,
        string[] memory publicKeyPems,
        string[] memory typesOfKey
    ) public returns (string memory) {
        require(bytes(addressToDID[msg.sender]).length == 0, "DID already exists for this address");
        require(publicKeyPems.length == typesOfKey.length, "Public keys and types of key arrays must have the same length");

        // Generate a unique DID
        string memory did = string(abi.encodePacked("did:dc:", toAsciiString(msg.sender)));

        // Create DID Document
        DIDDocument storage didDocument = didDocuments[did];
        didDocument.context = context;
        didDocument.id = did;
        didDocument.created = created;
        didDocument.updated = updated;
        didDocument.version = version;
        string[] memory key_id = new string[](10);
        key_id[0] = '1';
        key_id[1] = '2';
        key_id[2] = '3';
        key_id[3] = '4';
        key_id[4] = '5';
        key_id[5] = '6';
        key_id[6] = '7';
        key_id[7] = '8';
        key_id[8] = '9';
        key_id[9] = '10';
        // Loop through the public keys and types of key to create verification methods
        for (uint i = 0; i < publicKeyPems.length; i++) {
            // Generate VerificationMethod ID using the current index
            string memory verificationMethodId = string(abi.encodePacked(did, "#key-", key_id[i]));
            // Create VerificationMethod
            VerificationMethod memory verificationMethod = VerificationMethod({
                id: verificationMethodId,
                typeOfKey: typesOfKey[i],
                publicKeyPem: publicKeyPems[i],
                addr: msg.sender
            });

            // Add the verification method to the DID Document
            didDocument.verificationMethods.push(verificationMethod);
        }

        // Create Proof (initially empty, can be updated later)
        Proof memory proof = Proof({
            typeOfProof: "",
            created: "",
            proofPurpose: "",
            verificationMethod: "",
            proofValue: ""
        });

        didDocument.proof = proof;

        // Map address to DID
        addressToDID[msg.sender] = did;

        emit DIDCreated(did, msg.sender);

        return did;
    }

    function getDIDDocument(string memory did) public view returns (DIDDocument memory) {
        return didDocuments[did];
    }

    function addProof(
        string memory did,
        string memory typeOfProof,
        string memory created,
        string memory proofPurpose,
        string memory verificationMethod,
        string memory proofValue
    ) public {
        require(keccak256(abi.encodePacked(didDocuments[did].id)) == keccak256(abi.encodePacked(did)), "DID does not exist");

        DIDDocument storage didDocument = didDocuments[did];
        didDocument.proof = Proof({
            typeOfProof: typeOfProof,
            created: created,
            proofPurpose: proofPurpose,
            verificationMethod: verificationMethod,
            proofValue: proofValue
        });
    }

    function toAsciiString(address x) internal pure returns (string memory) {
        bytes memory s = new bytes(40);
        for (uint i = 0; i < 20; i++) {
            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));
            bytes1 hi = bytes1(uint8(b) / 16);
            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
            s[2*i] = char(hi);
            s[2*i+1] = char(lo);
        }
        return string(s);
    }

    function char(bytes1 b) internal pure returns (bytes1 c) {
        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
        else return bytes1(uint8(b) + 0x57);
    }
}
'''

# ç¼–è¯‘Solidityä»£ç 
compiled_sol = solcx.compile_source(contract_source_code, output_values=['abi', 'bin'])

# æå–åˆçº¦æŽ¥å£å’Œå­—èŠ‚ç 
contract_interface = compiled_sol['<stdin>:DIDRegistry']
abi = contract_interface['abi']
bytecode = contract_interface['bin']

# å°†ABIå’Œå­—èŠ‚ç ä¿å­˜åˆ°æ–‡ä»¶
with open('DIDRegistry_abi.json', 'w') as abi_file:
    json.dump(abi, abi_file)

with open('DIDRegistry_bytecode.txt', 'w') as bytecode_file:
    bytecode_file.write(bytecode)

print("ABI and Bytecode have been saved to DIDRegistry_abi.json and DIDRegistry_bytecode.txt")

----- End of web3src/complieSolidity.py -----

----- Start of web3src/verify_did.py -----
import json
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.exceptions import InvalidSignature
from .interact_with_contract import *
from .tuple_to_json import did_document_to_json

def verify_did(w3, abi, contract_address, did_document): # è¾“å…¥addr
    # ä»Ž DID æ–‡æ¡£ä¸­æå–å¿…è¦ä¿¡æ¯
    did = did_document["id"]
    proof = did_document["proof"]
    verification_method_id = proof["verificationMethod"]
    proof_value = proof["proofValue"]
    public_key_pem = None
    did_document = get_did_document(w3, abi, contract_address, did)
    # ä»ŽåŒºå—é“¾ä¸ŠèŽ·å– DID æ–‡æ¡£
    did_document_on_chain = did_document

    # æŸ¥æ‰¾å¯¹åº”çš„ verificationMethod
    for vm in did_document_on_chain[5]:  # verificationMethods is the 6th element in the tuple
        if vm[0] == verification_method_id:
            public_key_pem = vm[2]
            break

    if public_key_pem is None:
        return False
    did_document = did_document_to_json(did_document)
    proof = did_document["proof"]
    proof_value = proof["proofValue"]
    # åŠ è½½å…¬é’¥
    public_key = load_pem_public_key(public_key_pem.encode())
    # ååºåˆ—åŒ– DID æ–‡æ¡£å¹¶ç§»é™¤ proofValue å­—æ®µ
    did_document_copy = did_document.copy()
    del did_document_copy["proof"]
    did_document_json = json.dumps(did_document_copy).encode()
    # éªŒè¯ç­¾å
    try:
        public_key.verify(
            bytes.fromhex(proof_value),
            did_document_json,
            ec.ECDSA(hashes.SHA256())
        )
        # print(True, "Verification successful")
        return True
    except InvalidSignature:
        # print(False, "Invalid signature")
        return False
        # return {"msg": "Verification successful"}
    

# # test case
# a = {
#   "@context": ["buptBlockTrust"],
#   "id": "did:bbt:123456789abcdefghi",
#   "created": "2022-01-01T00:00:00Z",
#   "updated": "2022-01-10T10:00:00Z",
#   "version": "1",
#   "verificationMethod": [{
#     "id": "did:bbt:123456789abcdefghi#key-1",
#     "type": "SM2VerificationKey2022",
#     "publicKeyPem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoEcz1UBgi0DQgAEYbBKJ5xqkUaxYOoJlKkZIb2rhoVw\nZbjmyF9BRmOiBdp5Jde3QswKjicjMccB299I2n5UgQKdU8nPAY69Qiv5/w==\n-----END PUBLIC KEY-----",
#     "address": "0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF"
#   }],
#   "proof": {
#     "type": "SM2Signature",
#     "created": "2022-01-01T00:00:00Z",
#     "proofPurpose": "assertionMethod",
#     "verificationMethod": "did:bbt:123456789abcdefghi#key-1",
#     "proofValue": "eyJhbGciOiJFUzI1NksiLCJraWQiOiJkaWQ6ZXhhbXBsZToxMjM0NTY3ODlhYmNkZWZnaGlfa2V5LTEiLCJ0eXAiOiJKV1MifQ..Q9JYDNOU0oyJkXW5NcC1hR3U4SHN6U1RiY3pvYkUzam5vY3VtY2tjZERxY3dLd1Z0a1d0Z2pUa0dWY3A0bFZJZw"
#   }
# }
# b_dir = os.path.dirname(os.path.abspath(__file__))
# c_path = os.path.join(b_dir, 'contract_address.txt')
# with open (c_path,'r') as file:
#     contract_address = file.read()
# verify_did(contract_address = contract_address, did_document=a)
----- End of web3src/verify_did.py -----

----- Start of web3src/generate_key.py -----
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa, ec
from cryptography.hazmat.primitives.serialization import Encoding, PrivateFormat, NoEncryption, PublicFormat


def generate_keys(alg_type):
    if alg_type == 'RSA':
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
        )
        public_key = private_key.public_key()
    elif alg_type == 'SM2':
        private_key = ec.generate_private_key(ec.SECP256R1())
        public_key = private_key.public_key()
    else:
        print('Error: Invalid algorithm type. Please enter RSA or SM2')

    # Serializing the keys to PEM format
    pem_private_key = private_key.private_bytes(
        encoding=Encoding.PEM,
        format=PrivateFormat.PKCS8,
        encryption_algorithm=NoEncryption()
    ).decode()

    pem_public_key = public_key.public_bytes(
        encoding=Encoding.PEM,
        format=PublicFormat.SubjectPublicKeyInfo
    ).decode()

    return pem_private_key, pem_public_key
----- End of web3src/generate_key.py -----

----- Start of web3src/generate_vc.py -----
import json
import uuid
import base64
from datetime import datetime, timezone
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.exceptions import UnsupportedAlgorithm

def sign_json(json_bytes, private_key_pem, algorithm):
    # Load the private key from PEM
    private_key = load_pem_private_key(private_key_pem.encode(), password=None)

    if algorithm.upper() == 'RSA':
        signature = private_key.sign(
            json_bytes,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH,
            ),
            hashes.SHA256(),
        )
    elif algorithm.upper() == 'ECDSA':
        signature = private_key.sign(json_bytes, ec.ECDSA(hashes.SHA256()))
    else:
        raise UnsupportedAlgorithm(f'Unsupported algorithm: {algorithm}')

    return signature.hex()


def generate_vc(vc_type, issuer, credential_subject, key_id, private_key_pem, signature_algorithm):
    # å®šä¹‰ context
    context = "https://www.w3.org/2018/credentials/v1"

    # ç”Ÿæˆå”¯ä¸€çš„è¯ä¹¦ID
    vc_id = f"DeCertIssuer-{uuid.uuid4()}"

    # èŽ·å–å½“å‰æ—¶é—´ä½œä¸ºå‘è¡Œæ—¶é—´
    issuance_date = datetime.now(timezone.utc).isoformat()

    # æž„å»º VC è¯ä¹¦
    vc = {
        "@context": context,
        "id": vc_id,
        "type": ["VerifiableCredential", vc_type],
        "issuer": issuer,
        "issuanceDate": issuance_date,
        "credentialSubject": credential_subject,
    }

    # å¯¹ VC è¿›è¡Œç­¾å
    vc_data = json.dumps(vc).encode()
    proofValue = sign_json(vc_data, private_key_pem, signature_algorithm)

    # æž„å»º proof å¯¹è±¡
    proof = {
        "type": signature_algorithm,
        "created": datetime.now(timezone.utc).isoformat(),
        "proofPurpose": "assertionMethod",
        "verificationMethod": key_id,  # å‡è®¾å…¬é’¥IDæ˜¯ issuer/keys/1
        "proofValue": proofValue
    }

    # å°† proof æ·»åŠ åˆ° VC ä¸­
    vc["proof"] = proof

    return vc
#
#
# # ç¤ºä¾‹è¾“å…¥
# vc_type = ["AlumniCredential"]
# issuer = "https://example.edu/issuers/565049"
# credential_subject = {
#     "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
#     "alumniOf": {
#         "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
#         "value": "Example University",
#         "lang": "en"
#     }
# }
#
# # ç¤ºä¾‹ç§é’¥ï¼ˆPEM æ ¼å¼ï¼‰
# private_key_pem = """
# -----BEGIN RSA PRIVATE KEY-----
# MIIEpAIBAAKCAQEA1X1+zO2+Zs3Pj5F9Z9zj6K5FQ5U5v+F2Z2Y5Q5Y5d5Y5F5W5
# ...
# -----END RSA PRIVATE KEY-----
# """
#
# # ç”Ÿæˆ VC è¯ä¹¦
# vc_certificate = generate_vc(vc_type, issuer, credential_subject, private_key_pem)
#
# # æ‰“å°ç”Ÿæˆçš„ VC è¯ä¹¦
# print(json.dumps(vc_certificate, indent=2))
----- End of web3src/generate_vc.py -----

----- Start of src/test/testIdentifierRegistry.py -----
import requests
import json

# FlaskæœåŠ¡å™¨çš„URL
base_url = 'http://127.0.0.1:5000'

# æµ‹è¯•æ•°æ®
register_data = {
    "username": "testuser",
    "password": "testpass"
}

verify_did_data = {
  "@context": ["buptBlockTrust"],
  "id": "did:bbt:123456789abcdefghi", 
  "created": "2022-01-01T00:00:00Z",
  "updated": "2022-01-10T10:00:00Z", 
  "version": "1", 
  "verificationMethod": [{
    "id": "did:bbt:123456789abcdefghi#key-1",
    "type": "SM2VerificationKey2022", 
    "publicKeyPem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoEcz1UBgi0DQgAEYbBKJ5xqkUaxYOoJlKkZIb2rhoVw\nZbjmyF9BRmOiBdp5Jde3QswKjicjMccB299I2n5UgQKdU8nPAY69Qiv5/w==\n-----END PUBLIC KEY-----",
    "address": "0x4e0b15cAF28fD201A6ff5C17B3ff8227095462aA" 
  }],
  "proof": {
    "type": "SM2Signature", 
    "created": "2022-01-01T00:00:00Z",
    "proofPurpose": "assertionMethod", 
    "verificationMethod": "did:bbt:123456789abcdefghi#key-1", 
    "proofValue": "eyJhbGciOiJFUzI1NksiLCJraWQiOiJkaWQ6ZXhhbXBsZToxMjM0NTY3ODlhYmNkZWZnaGlfa2V5LTEiLCJ0eXAiOiJKV1MifQ..Q9JYDNOU0oyJkXW5NcC1hR3U4SHN6U1RiY3pvYkUzam5vY3VtY2tjZERxY3dLd1Z0a1d0Z2pUa0dWY3A0bFZJZw" 
  }
}

verify_vc_data = {
    "vc": "example_verifiable_credential"
}

verify_vp_data = {
    "vp": "example_verifiable_presentation"
}

# æ³¨å†Œè¯·æ±‚
# response = requests.post(f"{base_url}/register", json=register_data)
# print("Register response:", response.json())

# verifyDIDè¯·æ±‚
response = requests.post(f"{base_url}/verifyDID", json=verify_did_data)
print("verifyDID response:", response.text)

# # verifyVCè¯·æ±‚
# response = requests.post(f"{base_url}/verifyVC", json=verify_vc_data)
# print("verifyVC response:", response.json())

# # verifyVPè¯·æ±‚
# response = requests.post(f"{base_url}/verifyVP", json=verify_vp_data)
# print("verifyVP response:", response.json())

----- End of src/test/testIdentifierRegistry.py -----

